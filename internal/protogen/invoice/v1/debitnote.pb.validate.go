// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: invoice/v1/debitnote.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on DebitNoteHeader with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DebitNoteHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebitNoteHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DebitNoteHeaderMultiError, or nil if none found.
func (m *DebitNoteHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *DebitNoteHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDebitNoteHeaderD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteHeaderValidationError{
					field:  "DebitNoteHeaderD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteHeaderValidationError{
					field:  "DebitNoteHeaderD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDebitNoteHeaderD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteHeaderValidationError{
				field:  "DebitNoteHeaderD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDebitNoteHeaderT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteHeaderValidationError{
					field:  "DebitNoteHeaderT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteHeaderValidationError{
					field:  "DebitNoteHeaderT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDebitNoteHeaderT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteHeaderValidationError{
				field:  "DebitNoteHeaderT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteHeaderValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteHeaderValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteHeaderValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteHeaderValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteHeaderValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteHeaderValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DebitNoteHeaderMultiError(errors)
	}

	return nil
}

// DebitNoteHeaderMultiError is an error wrapping multiple validation errors
// returned by DebitNoteHeader.ValidateAll() if the designated constraints
// aren't met.
type DebitNoteHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebitNoteHeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebitNoteHeaderMultiError) AllErrors() []error { return m }

// DebitNoteHeaderValidationError is the validation error returned by
// DebitNoteHeader.Validate if the designated constraints aren't met.
type DebitNoteHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebitNoteHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebitNoteHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebitNoteHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebitNoteHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebitNoteHeaderValidationError) ErrorName() string { return "DebitNoteHeaderValidationError" }

// Error satisfies the builtin error interface
func (e DebitNoteHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebitNoteHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebitNoteHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebitNoteHeaderValidationError{}

// Validate checks the field values on DebitNoteHeaderD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DebitNoteHeaderD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebitNoteHeaderD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DebitNoteHeaderDMultiError, or nil if none found.
func (m *DebitNoteHeaderD) ValidateAll() error {
	return m.validate(true)
}

func (m *DebitNoteHeaderD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for DnhId

	// no validation rules for Note

	// no validation rules for DocumentCurrencyCode

	// no validation rules for TaxCurrencyCode

	// no validation rules for PricingCurrencyCode

	// no validation rules for PaymentCurrencyCode

	// no validation rules for PaymentAltCurrencyCode

	// no validation rules for AccountingCostCode

	// no validation rules for AccountingCost

	// no validation rules for LineCountNumeric

	// no validation rules for DiscrepancyResponse

	// no validation rules for OrderId

	// no validation rules for BillingId

	// no validation rules for DespatchId

	// no validation rules for ReceiptId

	// no validation rules for StatementId

	// no validation rules for ContractId

	// no validation rules for AccountingSupplierPartyId

	// no validation rules for AccountingCustomerPartyId

	// no validation rules for PayeePartyId

	// no validation rules for BuyerCustomerPartyId

	// no validation rules for SellerSupplierPartyId

	// no validation rules for TaxRepresentativePartyId

	// no validation rules for TaxExSourceCurrencyCode

	// no validation rules for TaxExSourceCurrencyBaseRate

	// no validation rules for TaxExTargetCurrencyCode

	// no validation rules for TaxExTargetCurrencyBaseRate

	// no validation rules for TaxExExchangeMarketId

	// no validation rules for TaxExCalculationRate

	// no validation rules for TaxExMathematicOperatorCode

	// no validation rules for PricingExSourceCurrencyCode

	// no validation rules for PricingExSourceCurrencyBaseRate

	// no validation rules for PricingExTargetCurrencyCode

	// no validation rules for PricingExTargetCurrencyBaseRate

	// no validation rules for PricingExExchangeMarketId

	// no validation rules for PricingExCalculationRate

	// no validation rules for PricingExMathematicOperatorCode

	// no validation rules for PaymentExSourceCurrencyCode

	// no validation rules for PaymentExSourceCurrencyBaseRate

	// no validation rules for PaymentExTargetCurrencyCode

	// no validation rules for PaymentExTargetCurrencyBaseRate

	// no validation rules for PaymentExExchangeMarketId

	// no validation rules for PaymentExCalculationRate

	// no validation rules for PaymentExMathematicOperatorCode

	// no validation rules for PaymentAltExSourceCurrencyCode

	// no validation rules for PaymentAltExSourceCurrencyBaseRate

	// no validation rules for PaymentAltExTargetCurrencyCode

	// no validation rules for PaymentAltExTargetCurrencyBaseRate

	// no validation rules for PaymentAltExExchangeMarketId

	// no validation rules for PaymentAltExCalculationRate

	// no validation rules for PaymentAltExMathematicOperatorCode

	// no validation rules for LineExtensionAmount

	// no validation rules for TaxExclusiveAmount

	// no validation rules for TaxInclusiveAmount

	// no validation rules for AllowanceTotalAmount

	// no validation rules for ChargeTotalAmount

	// no validation rules for WithholdingTaxTotalAmount

	// no validation rules for PrepaidAmount

	// no validation rules for PayableRoundingAmount

	// no validation rules for PayableAmount

	// no validation rules for PayableAlternativeAmount

	if len(errors) > 0 {
		return DebitNoteHeaderDMultiError(errors)
	}

	return nil
}

// DebitNoteHeaderDMultiError is an error wrapping multiple validation errors
// returned by DebitNoteHeaderD.ValidateAll() if the designated constraints
// aren't met.
type DebitNoteHeaderDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebitNoteHeaderDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebitNoteHeaderDMultiError) AllErrors() []error { return m }

// DebitNoteHeaderDValidationError is the validation error returned by
// DebitNoteHeaderD.Validate if the designated constraints aren't met.
type DebitNoteHeaderDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebitNoteHeaderDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebitNoteHeaderDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebitNoteHeaderDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebitNoteHeaderDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebitNoteHeaderDValidationError) ErrorName() string { return "DebitNoteHeaderDValidationError" }

// Error satisfies the builtin error interface
func (e DebitNoteHeaderDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebitNoteHeaderD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebitNoteHeaderDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebitNoteHeaderDValidationError{}

// Validate checks the field values on DebitNoteHeaderT with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DebitNoteHeaderT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebitNoteHeaderT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DebitNoteHeaderTMultiError, or nil if none found.
func (m *DebitNoteHeaderT) ValidateAll() error {
	return m.validate(true)
}

func (m *DebitNoteHeaderT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIssueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteHeaderTValidationError{
				field:  "IssueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTaxPointDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "TaxPointDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "TaxPointDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxPointDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteHeaderTValidationError{
				field:  "TaxPointDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvoicePeriodStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "InvoicePeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "InvoicePeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoicePeriodStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteHeaderTValidationError{
				field:  "InvoicePeriodStartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvoicePeriodEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "InvoicePeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "InvoicePeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoicePeriodEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteHeaderTValidationError{
				field:  "InvoicePeriodEndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTaxExDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "TaxExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "TaxExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxExDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteHeaderTValidationError{
				field:  "TaxExDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPricingExDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "PricingExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "PricingExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPricingExDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteHeaderTValidationError{
				field:  "PricingExDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPaymentExDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "PaymentExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "PaymentExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaymentExDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteHeaderTValidationError{
				field:  "PaymentExDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPaymentAltExDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "PaymentAltExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteHeaderTValidationError{
					field:  "PaymentAltExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaymentAltExDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteHeaderTValidationError{
				field:  "PaymentAltExDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DebitNoteHeaderTMultiError(errors)
	}

	return nil
}

// DebitNoteHeaderTMultiError is an error wrapping multiple validation errors
// returned by DebitNoteHeaderT.ValidateAll() if the designated constraints
// aren't met.
type DebitNoteHeaderTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebitNoteHeaderTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebitNoteHeaderTMultiError) AllErrors() []error { return m }

// DebitNoteHeaderTValidationError is the validation error returned by
// DebitNoteHeaderT.Validate if the designated constraints aren't met.
type DebitNoteHeaderTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebitNoteHeaderTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebitNoteHeaderTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebitNoteHeaderTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebitNoteHeaderTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebitNoteHeaderTValidationError) ErrorName() string { return "DebitNoteHeaderTValidationError" }

// Error satisfies the builtin error interface
func (e DebitNoteHeaderTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebitNoteHeaderT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebitNoteHeaderTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebitNoteHeaderTValidationError{}

// Validate checks the field values on CreateDebitNoteHeaderRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDebitNoteHeaderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDebitNoteHeaderRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDebitNoteHeaderRequestMultiError, or nil if none found.
func (m *CreateDebitNoteHeaderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDebitNoteHeaderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DnhId

	// no validation rules for IssueDate

	// no validation rules for Note

	// no validation rules for TaxPointDate

	// no validation rules for DocumentCurrencyCode

	// no validation rules for TaxCurrencyCode

	// no validation rules for PricingCurrencyCode

	// no validation rules for PaymentCurrencyCode

	// no validation rules for PaymentAltCurrencyCode

	// no validation rules for AccountingCostCode

	// no validation rules for AccountingCost

	// no validation rules for LineCountNumeric

	// no validation rules for InvoicePeriodStartDate

	// no validation rules for InvoicePeriodEndDate

	// no validation rules for DiscrepancyResponse

	// no validation rules for OrderId

	// no validation rules for BillingId

	// no validation rules for DespatchId

	// no validation rules for ReceiptId

	// no validation rules for StatementId

	// no validation rules for ContractId

	// no validation rules for AccountingSupplierPartyId

	// no validation rules for AccountingCustomerPartyId

	// no validation rules for PayeePartyId

	// no validation rules for BuyerCustomerPartyId

	// no validation rules for SellerSupplierPartyId

	// no validation rules for TaxRepresentativePartyId

	// no validation rules for TaxExSourceCurrencyCode

	// no validation rules for TaxExSourceCurrencyBaseRate

	// no validation rules for TaxExTargetCurrencyCode

	// no validation rules for TaxExTargetCurrencyBaseRate

	// no validation rules for TaxExExchangeMarketId

	// no validation rules for TaxExCalculationRate

	// no validation rules for TaxExMathematicOperatorCode

	// no validation rules for TaxExDate

	// no validation rules for PricingExSourceCurrencyCode

	// no validation rules for PricingExSourceCurrencyBaseRate

	// no validation rules for PricingExTargetCurrencyCode

	// no validation rules for PricingExTargetCurrencyBaseRate

	// no validation rules for PricingExExchangeMarketId

	// no validation rules for PricingExCalculationRate

	// no validation rules for PricingExMathematicOperatorCode

	// no validation rules for PricingExDate

	// no validation rules for PaymentExSourceCurrencyCode

	// no validation rules for PaymentExSourceCurrencyBaseRate

	// no validation rules for PaymentExTargetCurrencyCode

	// no validation rules for PaymentExTargetCurrencyBaseRate

	// no validation rules for PaymentExExchangeMarketId

	// no validation rules for PaymentExCalculationRate

	// no validation rules for PaymentExMathematicOperatorCode

	// no validation rules for PaymentExDate

	// no validation rules for PaymentAltExSourceCurrencyCode

	// no validation rules for PaymentAltExSourceCurrencyBaseRate

	// no validation rules for PaymentAltExTargetCurrencyCode

	// no validation rules for PaymentAltExTargetCurrencyBaseRate

	// no validation rules for PaymentAltExExchangeMarketId

	// no validation rules for PaymentAltExCalculationRate

	// no validation rules for PaymentAltExMathematicOperatorCode

	// no validation rules for PaymentAltExDate

	// no validation rules for LineExtensionAmount

	// no validation rules for TaxExclusiveAmount

	// no validation rules for TaxInclusiveAmount

	// no validation rules for AllowanceTotalAmount

	// no validation rules for ChargeTotalAmount

	// no validation rules for WithholdingTaxTotalAmount

	// no validation rules for PrepaidAmount

	// no validation rules for PayableRoundingAmount

	// no validation rules for PayableAmount

	// no validation rules for PayableAlternativeAmount

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	for idx, item := range m.GetDebitNoteLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateDebitNoteHeaderRequestValidationError{
						field:  fmt.Sprintf("DebitNoteLines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateDebitNoteHeaderRequestValidationError{
						field:  fmt.Sprintf("DebitNoteLines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateDebitNoteHeaderRequestValidationError{
					field:  fmt.Sprintf("DebitNoteLines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateDebitNoteHeaderRequestMultiError(errors)
	}

	return nil
}

// CreateDebitNoteHeaderRequestMultiError is an error wrapping multiple
// validation errors returned by CreateDebitNoteHeaderRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateDebitNoteHeaderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDebitNoteHeaderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDebitNoteHeaderRequestMultiError) AllErrors() []error { return m }

// CreateDebitNoteHeaderRequestValidationError is the validation error returned
// by CreateDebitNoteHeaderRequest.Validate if the designated constraints
// aren't met.
type CreateDebitNoteHeaderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDebitNoteHeaderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDebitNoteHeaderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDebitNoteHeaderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDebitNoteHeaderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDebitNoteHeaderRequestValidationError) ErrorName() string {
	return "CreateDebitNoteHeaderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDebitNoteHeaderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDebitNoteHeaderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDebitNoteHeaderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDebitNoteHeaderRequestValidationError{}

// Validate checks the field values on CreateDebitNoteHeaderResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDebitNoteHeaderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDebitNoteHeaderResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateDebitNoteHeaderResponseMultiError, or nil if none found.
func (m *CreateDebitNoteHeaderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDebitNoteHeaderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDebitNoteHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDebitNoteHeaderResponseValidationError{
					field:  "DebitNoteHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDebitNoteHeaderResponseValidationError{
					field:  "DebitNoteHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDebitNoteHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDebitNoteHeaderResponseValidationError{
				field:  "DebitNoteHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateDebitNoteHeaderResponseMultiError(errors)
	}

	return nil
}

// CreateDebitNoteHeaderResponseMultiError is an error wrapping multiple
// validation errors returned by CreateDebitNoteHeaderResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateDebitNoteHeaderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDebitNoteHeaderResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDebitNoteHeaderResponseMultiError) AllErrors() []error { return m }

// CreateDebitNoteHeaderResponseValidationError is the validation error
// returned by CreateDebitNoteHeaderResponse.Validate if the designated
// constraints aren't met.
type CreateDebitNoteHeaderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDebitNoteHeaderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDebitNoteHeaderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDebitNoteHeaderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDebitNoteHeaderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDebitNoteHeaderResponseValidationError) ErrorName() string {
	return "CreateDebitNoteHeaderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDebitNoteHeaderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDebitNoteHeaderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDebitNoteHeaderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDebitNoteHeaderResponseValidationError{}

// Validate checks the field values on UpdateDebitNoteHeaderRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDebitNoteHeaderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDebitNoteHeaderRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateDebitNoteHeaderRequestMultiError, or nil if none found.
func (m *UpdateDebitNoteHeaderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDebitNoteHeaderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Note

	// no validation rules for DocumentCurrencyCode

	// no validation rules for AccountingCost

	// no validation rules for ChargeTotalAmount

	// no validation rules for PrepaidAmount

	// no validation rules for PayableRoundingAmount

	// no validation rules for PayableAmount

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return UpdateDebitNoteHeaderRequestMultiError(errors)
	}

	return nil
}

// UpdateDebitNoteHeaderRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateDebitNoteHeaderRequest.ValidateAll() if
// the designated constraints aren't met.
type UpdateDebitNoteHeaderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDebitNoteHeaderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDebitNoteHeaderRequestMultiError) AllErrors() []error { return m }

// UpdateDebitNoteHeaderRequestValidationError is the validation error returned
// by UpdateDebitNoteHeaderRequest.Validate if the designated constraints
// aren't met.
type UpdateDebitNoteHeaderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDebitNoteHeaderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDebitNoteHeaderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDebitNoteHeaderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDebitNoteHeaderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDebitNoteHeaderRequestValidationError) ErrorName() string {
	return "UpdateDebitNoteHeaderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDebitNoteHeaderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDebitNoteHeaderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDebitNoteHeaderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDebitNoteHeaderRequestValidationError{}

// Validate checks the field values on UpdateDebitNoteHeaderResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateDebitNoteHeaderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateDebitNoteHeaderResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateDebitNoteHeaderResponseMultiError, or nil if none found.
func (m *UpdateDebitNoteHeaderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateDebitNoteHeaderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateDebitNoteHeaderResponseMultiError(errors)
	}

	return nil
}

// UpdateDebitNoteHeaderResponseMultiError is an error wrapping multiple
// validation errors returned by UpdateDebitNoteHeaderResponse.ValidateAll()
// if the designated constraints aren't met.
type UpdateDebitNoteHeaderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDebitNoteHeaderResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDebitNoteHeaderResponseMultiError) AllErrors() []error { return m }

// UpdateDebitNoteHeaderResponseValidationError is the validation error
// returned by UpdateDebitNoteHeaderResponse.Validate if the designated
// constraints aren't met.
type UpdateDebitNoteHeaderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDebitNoteHeaderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDebitNoteHeaderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDebitNoteHeaderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDebitNoteHeaderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDebitNoteHeaderResponseValidationError) ErrorName() string {
	return "UpdateDebitNoteHeaderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDebitNoteHeaderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDebitNoteHeaderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDebitNoteHeaderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDebitNoteHeaderResponseValidationError{}

// Validate checks the field values on GetDebitNoteHeaderRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDebitNoteHeaderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDebitNoteHeaderRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDebitNoteHeaderRequestMultiError, or nil if none found.
func (m *GetDebitNoteHeaderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDebitNoteHeaderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDebitNoteHeaderRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDebitNoteHeaderRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDebitNoteHeaderRequestValidationError{
				field:  "GetRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDebitNoteHeaderRequestMultiError(errors)
	}

	return nil
}

// GetDebitNoteHeaderRequestMultiError is an error wrapping multiple validation
// errors returned by GetDebitNoteHeaderRequest.ValidateAll() if the
// designated constraints aren't met.
type GetDebitNoteHeaderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDebitNoteHeaderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDebitNoteHeaderRequestMultiError) AllErrors() []error { return m }

// GetDebitNoteHeaderRequestValidationError is the validation error returned by
// GetDebitNoteHeaderRequest.Validate if the designated constraints aren't met.
type GetDebitNoteHeaderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDebitNoteHeaderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDebitNoteHeaderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDebitNoteHeaderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDebitNoteHeaderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDebitNoteHeaderRequestValidationError) ErrorName() string {
	return "GetDebitNoteHeaderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDebitNoteHeaderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDebitNoteHeaderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDebitNoteHeaderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDebitNoteHeaderRequestValidationError{}

// Validate checks the field values on GetDebitNoteHeaderResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDebitNoteHeaderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDebitNoteHeaderResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDebitNoteHeaderResponseMultiError, or nil if none found.
func (m *GetDebitNoteHeaderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDebitNoteHeaderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDebitNoteHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDebitNoteHeaderResponseValidationError{
					field:  "DebitNoteHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDebitNoteHeaderResponseValidationError{
					field:  "DebitNoteHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDebitNoteHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDebitNoteHeaderResponseValidationError{
				field:  "DebitNoteHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDebitNoteHeaderResponseMultiError(errors)
	}

	return nil
}

// GetDebitNoteHeaderResponseMultiError is an error wrapping multiple
// validation errors returned by GetDebitNoteHeaderResponse.ValidateAll() if
// the designated constraints aren't met.
type GetDebitNoteHeaderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDebitNoteHeaderResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDebitNoteHeaderResponseMultiError) AllErrors() []error { return m }

// GetDebitNoteHeaderResponseValidationError is the validation error returned
// by GetDebitNoteHeaderResponse.Validate if the designated constraints aren't met.
type GetDebitNoteHeaderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDebitNoteHeaderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDebitNoteHeaderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDebitNoteHeaderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDebitNoteHeaderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDebitNoteHeaderResponseValidationError) ErrorName() string {
	return "GetDebitNoteHeaderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDebitNoteHeaderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDebitNoteHeaderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDebitNoteHeaderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDebitNoteHeaderResponseValidationError{}

// Validate checks the field values on GetDebitNoteHeaderByPkRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDebitNoteHeaderByPkRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDebitNoteHeaderByPkRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetDebitNoteHeaderByPkRequestMultiError, or nil if none found.
func (m *GetDebitNoteHeaderByPkRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDebitNoteHeaderByPkRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetByIdRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDebitNoteHeaderByPkRequestValidationError{
					field:  "GetByIdRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDebitNoteHeaderByPkRequestValidationError{
					field:  "GetByIdRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetByIdRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDebitNoteHeaderByPkRequestValidationError{
				field:  "GetByIdRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDebitNoteHeaderByPkRequestMultiError(errors)
	}

	return nil
}

// GetDebitNoteHeaderByPkRequestMultiError is an error wrapping multiple
// validation errors returned by GetDebitNoteHeaderByPkRequest.ValidateAll()
// if the designated constraints aren't met.
type GetDebitNoteHeaderByPkRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDebitNoteHeaderByPkRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDebitNoteHeaderByPkRequestMultiError) AllErrors() []error { return m }

// GetDebitNoteHeaderByPkRequestValidationError is the validation error
// returned by GetDebitNoteHeaderByPkRequest.Validate if the designated
// constraints aren't met.
type GetDebitNoteHeaderByPkRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDebitNoteHeaderByPkRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDebitNoteHeaderByPkRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDebitNoteHeaderByPkRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDebitNoteHeaderByPkRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDebitNoteHeaderByPkRequestValidationError) ErrorName() string {
	return "GetDebitNoteHeaderByPkRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDebitNoteHeaderByPkRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDebitNoteHeaderByPkRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDebitNoteHeaderByPkRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDebitNoteHeaderByPkRequestValidationError{}

// Validate checks the field values on GetDebitNoteHeaderByPkResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDebitNoteHeaderByPkResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDebitNoteHeaderByPkResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetDebitNoteHeaderByPkResponseMultiError, or nil if none found.
func (m *GetDebitNoteHeaderByPkResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDebitNoteHeaderByPkResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDebitNoteHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDebitNoteHeaderByPkResponseValidationError{
					field:  "DebitNoteHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDebitNoteHeaderByPkResponseValidationError{
					field:  "DebitNoteHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDebitNoteHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDebitNoteHeaderByPkResponseValidationError{
				field:  "DebitNoteHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDebitNoteHeaderByPkResponseMultiError(errors)
	}

	return nil
}

// GetDebitNoteHeaderByPkResponseMultiError is an error wrapping multiple
// validation errors returned by GetDebitNoteHeaderByPkResponse.ValidateAll()
// if the designated constraints aren't met.
type GetDebitNoteHeaderByPkResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDebitNoteHeaderByPkResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDebitNoteHeaderByPkResponseMultiError) AllErrors() []error { return m }

// GetDebitNoteHeaderByPkResponseValidationError is the validation error
// returned by GetDebitNoteHeaderByPkResponse.Validate if the designated
// constraints aren't met.
type GetDebitNoteHeaderByPkResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDebitNoteHeaderByPkResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDebitNoteHeaderByPkResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDebitNoteHeaderByPkResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDebitNoteHeaderByPkResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDebitNoteHeaderByPkResponseValidationError) ErrorName() string {
	return "GetDebitNoteHeaderByPkResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDebitNoteHeaderByPkResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDebitNoteHeaderByPkResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDebitNoteHeaderByPkResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDebitNoteHeaderByPkResponseValidationError{}

// Validate checks the field values on GetDebitNoteHeadersRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDebitNoteHeadersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDebitNoteHeadersRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDebitNoteHeadersRequestMultiError, or nil if none found.
func (m *GetDebitNoteHeadersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDebitNoteHeadersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for NextCursor

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetDebitNoteHeadersRequestMultiError(errors)
	}

	return nil
}

// GetDebitNoteHeadersRequestMultiError is an error wrapping multiple
// validation errors returned by GetDebitNoteHeadersRequest.ValidateAll() if
// the designated constraints aren't met.
type GetDebitNoteHeadersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDebitNoteHeadersRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDebitNoteHeadersRequestMultiError) AllErrors() []error { return m }

// GetDebitNoteHeadersRequestValidationError is the validation error returned
// by GetDebitNoteHeadersRequest.Validate if the designated constraints aren't met.
type GetDebitNoteHeadersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDebitNoteHeadersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDebitNoteHeadersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDebitNoteHeadersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDebitNoteHeadersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDebitNoteHeadersRequestValidationError) ErrorName() string {
	return "GetDebitNoteHeadersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDebitNoteHeadersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDebitNoteHeadersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDebitNoteHeadersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDebitNoteHeadersRequestValidationError{}

// Validate checks the field values on GetDebitNoteHeadersResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDebitNoteHeadersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDebitNoteHeadersResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDebitNoteHeadersResponseMultiError, or nil if none found.
func (m *GetDebitNoteHeadersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDebitNoteHeadersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDebitNoteHeaders() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDebitNoteHeadersResponseValidationError{
						field:  fmt.Sprintf("DebitNoteHeaders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDebitNoteHeadersResponseValidationError{
						field:  fmt.Sprintf("DebitNoteHeaders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDebitNoteHeadersResponseValidationError{
					field:  fmt.Sprintf("DebitNoteHeaders[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextCursor

	if len(errors) > 0 {
		return GetDebitNoteHeadersResponseMultiError(errors)
	}

	return nil
}

// GetDebitNoteHeadersResponseMultiError is an error wrapping multiple
// validation errors returned by GetDebitNoteHeadersResponse.ValidateAll() if
// the designated constraints aren't met.
type GetDebitNoteHeadersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDebitNoteHeadersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDebitNoteHeadersResponseMultiError) AllErrors() []error { return m }

// GetDebitNoteHeadersResponseValidationError is the validation error returned
// by GetDebitNoteHeadersResponse.Validate if the designated constraints
// aren't met.
type GetDebitNoteHeadersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDebitNoteHeadersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDebitNoteHeadersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDebitNoteHeadersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDebitNoteHeadersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDebitNoteHeadersResponseValidationError) ErrorName() string {
	return "GetDebitNoteHeadersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDebitNoteHeadersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDebitNoteHeadersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDebitNoteHeadersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDebitNoteHeadersResponseValidationError{}

// Validate checks the field values on DebitNoteLine with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DebitNoteLine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebitNoteLine with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DebitNoteLineMultiError, or
// nil if none found.
func (m *DebitNoteLine) ValidateAll() error {
	return m.validate(true)
}

func (m *DebitNoteLine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDebitNoteLineD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteLineValidationError{
					field:  "DebitNoteLineD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteLineValidationError{
					field:  "DebitNoteLineD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDebitNoteLineD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteLineValidationError{
				field:  "DebitNoteLineD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDebitNoteLineT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteLineValidationError{
					field:  "DebitNoteLineT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteLineValidationError{
					field:  "DebitNoteLineT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDebitNoteLineT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteLineValidationError{
				field:  "DebitNoteLineT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteLineValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteLineValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteLineValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteLineValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteLineValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteLineValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DebitNoteLineMultiError(errors)
	}

	return nil
}

// DebitNoteLineMultiError is an error wrapping multiple validation errors
// returned by DebitNoteLine.ValidateAll() if the designated constraints
// aren't met.
type DebitNoteLineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebitNoteLineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebitNoteLineMultiError) AllErrors() []error { return m }

// DebitNoteLineValidationError is the validation error returned by
// DebitNoteLine.Validate if the designated constraints aren't met.
type DebitNoteLineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebitNoteLineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebitNoteLineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebitNoteLineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebitNoteLineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebitNoteLineValidationError) ErrorName() string { return "DebitNoteLineValidationError" }

// Error satisfies the builtin error interface
func (e DebitNoteLineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebitNoteLine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebitNoteLineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebitNoteLineValidationError{}

// Validate checks the field values on DebitNoteLineD with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DebitNoteLineD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebitNoteLineD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DebitNoteLineDMultiError,
// or nil if none found.
func (m *DebitNoteLineD) ValidateAll() error {
	return m.validate(true)
}

func (m *DebitNoteLineD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for DnlId

	// no validation rules for Note

	// no validation rules for DebitedQuantity

	// no validation rules for LineExtensionAmount

	// no validation rules for AccountingCostCode

	// no validation rules for AccountingCost

	// no validation rules for PaymentPurposeCode

	// no validation rules for DiscrepancyResponse

	// no validation rules for DespatchLineId

	// no validation rules for ReceiptLineId

	// no validation rules for BillingId

	// no validation rules for ItemId

	// no validation rules for PriceAmount

	// no validation rules for PriceBaseQuantity

	// no validation rules for PriceChangeReason

	// no validation rules for PriceTypeCode

	// no validation rules for PriceType

	// no validation rules for OrderableUnitFactorRate

	// no validation rules for PriceListId

	// no validation rules for DebitNoteHeaderId

	if len(errors) > 0 {
		return DebitNoteLineDMultiError(errors)
	}

	return nil
}

// DebitNoteLineDMultiError is an error wrapping multiple validation errors
// returned by DebitNoteLineD.ValidateAll() if the designated constraints
// aren't met.
type DebitNoteLineDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebitNoteLineDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebitNoteLineDMultiError) AllErrors() []error { return m }

// DebitNoteLineDValidationError is the validation error returned by
// DebitNoteLineD.Validate if the designated constraints aren't met.
type DebitNoteLineDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebitNoteLineDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebitNoteLineDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebitNoteLineDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebitNoteLineDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebitNoteLineDValidationError) ErrorName() string { return "DebitNoteLineDValidationError" }

// Error satisfies the builtin error interface
func (e DebitNoteLineDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebitNoteLineD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebitNoteLineDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebitNoteLineDValidationError{}

// Validate checks the field values on DebitNoteLineT with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DebitNoteLineT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DebitNoteLineT with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DebitNoteLineTMultiError,
// or nil if none found.
func (m *DebitNoteLineT) ValidateAll() error {
	return m.validate(true)
}

func (m *DebitNoteLineT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaxPointDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteLineTValidationError{
					field:  "TaxPointDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteLineTValidationError{
					field:  "TaxPointDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxPointDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteLineTValidationError{
				field:  "TaxPointDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPriceValidityPeriodStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteLineTValidationError{
					field:  "PriceValidityPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteLineTValidationError{
					field:  "PriceValidityPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPriceValidityPeriodStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteLineTValidationError{
				field:  "PriceValidityPeriodStartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPriceValidityPeriodEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DebitNoteLineTValidationError{
					field:  "PriceValidityPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DebitNoteLineTValidationError{
					field:  "PriceValidityPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPriceValidityPeriodEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DebitNoteLineTValidationError{
				field:  "PriceValidityPeriodEndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DebitNoteLineTMultiError(errors)
	}

	return nil
}

// DebitNoteLineTMultiError is an error wrapping multiple validation errors
// returned by DebitNoteLineT.ValidateAll() if the designated constraints
// aren't met.
type DebitNoteLineTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DebitNoteLineTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DebitNoteLineTMultiError) AllErrors() []error { return m }

// DebitNoteLineTValidationError is the validation error returned by
// DebitNoteLineT.Validate if the designated constraints aren't met.
type DebitNoteLineTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DebitNoteLineTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DebitNoteLineTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DebitNoteLineTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DebitNoteLineTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DebitNoteLineTValidationError) ErrorName() string { return "DebitNoteLineTValidationError" }

// Error satisfies the builtin error interface
func (e DebitNoteLineTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDebitNoteLineT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DebitNoteLineTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DebitNoteLineTValidationError{}

// Validate checks the field values on CreateDebitNoteLineRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDebitNoteLineRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDebitNoteLineRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDebitNoteLineRequestMultiError, or nil if none found.
func (m *CreateDebitNoteLineRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDebitNoteLineRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DnlId

	// no validation rules for Note

	// no validation rules for DebitedQuantity

	// no validation rules for LineExtensionAmount

	// no validation rules for TaxPointDate

	// no validation rules for AccountingCostCode

	// no validation rules for AccountingCost

	// no validation rules for PaymentPurposeCode

	// no validation rules for DiscrepancyResponse

	// no validation rules for DespatchLineId

	// no validation rules for ReceiptLineId

	// no validation rules for BillingId

	// no validation rules for ItemId

	// no validation rules for PriceAmount

	// no validation rules for PriceBaseQuantity

	// no validation rules for PriceChangeReason

	// no validation rules for PriceTypeCode

	// no validation rules for PriceType

	// no validation rules for OrderableUnitFactorRate

	// no validation rules for PriceValidityPeriodStartDate

	// no validation rules for PriceValidityPeriodEndDate

	// no validation rules for PriceListId

	// no validation rules for DebitNoteHeaderId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateDebitNoteLineRequestMultiError(errors)
	}

	return nil
}

// CreateDebitNoteLineRequestMultiError is an error wrapping multiple
// validation errors returned by CreateDebitNoteLineRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateDebitNoteLineRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDebitNoteLineRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDebitNoteLineRequestMultiError) AllErrors() []error { return m }

// CreateDebitNoteLineRequestValidationError is the validation error returned
// by CreateDebitNoteLineRequest.Validate if the designated constraints aren't met.
type CreateDebitNoteLineRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDebitNoteLineRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDebitNoteLineRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDebitNoteLineRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDebitNoteLineRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDebitNoteLineRequestValidationError) ErrorName() string {
	return "CreateDebitNoteLineRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDebitNoteLineRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDebitNoteLineRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDebitNoteLineRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDebitNoteLineRequestValidationError{}

// Validate checks the field values on CreateDebitNoteLineResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDebitNoteLineResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDebitNoteLineResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDebitNoteLineResponseMultiError, or nil if none found.
func (m *CreateDebitNoteLineResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDebitNoteLineResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDebitNoteLine()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDebitNoteLineResponseValidationError{
					field:  "DebitNoteLine",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDebitNoteLineResponseValidationError{
					field:  "DebitNoteLine",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDebitNoteLine()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDebitNoteLineResponseValidationError{
				field:  "DebitNoteLine",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateDebitNoteLineResponseMultiError(errors)
	}

	return nil
}

// CreateDebitNoteLineResponseMultiError is an error wrapping multiple
// validation errors returned by CreateDebitNoteLineResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateDebitNoteLineResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDebitNoteLineResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDebitNoteLineResponseMultiError) AllErrors() []error { return m }

// CreateDebitNoteLineResponseValidationError is the validation error returned
// by CreateDebitNoteLineResponse.Validate if the designated constraints
// aren't met.
type CreateDebitNoteLineResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDebitNoteLineResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDebitNoteLineResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDebitNoteLineResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDebitNoteLineResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDebitNoteLineResponseValidationError) ErrorName() string {
	return "CreateDebitNoteLineResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDebitNoteLineResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDebitNoteLineResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDebitNoteLineResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDebitNoteLineResponseValidationError{}

// Validate checks the field values on GetDebitNoteLinesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDebitNoteLinesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDebitNoteLinesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDebitNoteLinesRequestMultiError, or nil if none found.
func (m *GetDebitNoteLinesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDebitNoteLinesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetDebitNoteLinesRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetDebitNoteLinesRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetDebitNoteLinesRequestValidationError{
				field:  "GetRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetDebitNoteLinesRequestMultiError(errors)
	}

	return nil
}

// GetDebitNoteLinesRequestMultiError is an error wrapping multiple validation
// errors returned by GetDebitNoteLinesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetDebitNoteLinesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDebitNoteLinesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDebitNoteLinesRequestMultiError) AllErrors() []error { return m }

// GetDebitNoteLinesRequestValidationError is the validation error returned by
// GetDebitNoteLinesRequest.Validate if the designated constraints aren't met.
type GetDebitNoteLinesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDebitNoteLinesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDebitNoteLinesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDebitNoteLinesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDebitNoteLinesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDebitNoteLinesRequestValidationError) ErrorName() string {
	return "GetDebitNoteLinesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetDebitNoteLinesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDebitNoteLinesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDebitNoteLinesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDebitNoteLinesRequestValidationError{}

// Validate checks the field values on GetDebitNoteLinesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetDebitNoteLinesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetDebitNoteLinesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetDebitNoteLinesResponseMultiError, or nil if none found.
func (m *GetDebitNoteLinesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetDebitNoteLinesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDebitNoteLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetDebitNoteLinesResponseValidationError{
						field:  fmt.Sprintf("DebitNoteLines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetDebitNoteLinesResponseValidationError{
						field:  fmt.Sprintf("DebitNoteLines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetDebitNoteLinesResponseValidationError{
					field:  fmt.Sprintf("DebitNoteLines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetDebitNoteLinesResponseMultiError(errors)
	}

	return nil
}

// GetDebitNoteLinesResponseMultiError is an error wrapping multiple validation
// errors returned by GetDebitNoteLinesResponse.ValidateAll() if the
// designated constraints aren't met.
type GetDebitNoteLinesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetDebitNoteLinesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetDebitNoteLinesResponseMultiError) AllErrors() []error { return m }

// GetDebitNoteLinesResponseValidationError is the validation error returned by
// GetDebitNoteLinesResponse.Validate if the designated constraints aren't met.
type GetDebitNoteLinesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetDebitNoteLinesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetDebitNoteLinesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetDebitNoteLinesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetDebitNoteLinesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetDebitNoteLinesResponseValidationError) ErrorName() string {
	return "GetDebitNoteLinesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetDebitNoteLinesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetDebitNoteLinesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetDebitNoteLinesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetDebitNoteLinesResponseValidationError{}
