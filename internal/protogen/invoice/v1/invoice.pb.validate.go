// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: invoice/v1/invoice.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on InvoiceHeader with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceHeader with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceHeaderMultiError, or
// nil if none found.
func (m *InvoiceHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoiceHeaderD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceHeaderValidationError{
					field:  "InvoiceHeaderD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceHeaderValidationError{
					field:  "InvoiceHeaderD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceHeaderD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceHeaderValidationError{
				field:  "InvoiceHeaderD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvoiceHeaderT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceHeaderValidationError{
					field:  "InvoiceHeaderT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceHeaderValidationError{
					field:  "InvoiceHeaderT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceHeaderT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceHeaderValidationError{
				field:  "InvoiceHeaderT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceHeaderValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceHeaderValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceHeaderValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceHeaderValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceHeaderValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceHeaderValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceHeaderMultiError(errors)
	}

	return nil
}

// InvoiceHeaderMultiError is an error wrapping multiple validation errors
// returned by InvoiceHeader.ValidateAll() if the designated constraints
// aren't met.
type InvoiceHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceHeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceHeaderMultiError) AllErrors() []error { return m }

// InvoiceHeaderValidationError is the validation error returned by
// InvoiceHeader.Validate if the designated constraints aren't met.
type InvoiceHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceHeaderValidationError) ErrorName() string { return "InvoiceHeaderValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceHeaderValidationError{}

// Validate checks the field values on InvoiceHeaderD with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceHeaderD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceHeaderD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceHeaderDMultiError,
// or nil if none found.
func (m *InvoiceHeaderD) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceHeaderD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for IhId

	// no validation rules for InvoiceTypeCode

	// no validation rules for Note

	// no validation rules for DocumentCurrencyCode

	// no validation rules for TaxCurrencyCode

	// no validation rules for PricingCurrencyCode

	// no validation rules for PaymentCurrencyCode

	// no validation rules for PaymentAltCurrencyCode

	// no validation rules for AccountingCostCode

	// no validation rules for AccountingCost

	// no validation rules for LineCountNumeric

	// no validation rules for OrderId

	// no validation rules for BillingId

	// no validation rules for DespatchId

	// no validation rules for ReceiptId

	// no validation rules for StatementId

	// no validation rules for ContractId

	// no validation rules for AccountingSupplierPartyId

	// no validation rules for AccountingCustomerPartyId

	// no validation rules for PayeePartyId

	// no validation rules for BuyerCustomerPartyId

	// no validation rules for SellerSupplierPartyId

	// no validation rules for TaxRepresentativePartyId

	// no validation rules for TaxExSourceCurrencyCode

	// no validation rules for TaxExSourceCurrencyBaseRate

	// no validation rules for TaxExTargetCurrencyCode

	// no validation rules for TaxExTargetCurrencyBaseRate

	// no validation rules for TaxExExchangeMarketId

	// no validation rules for TaxExCalculationRate

	// no validation rules for TaxExMathematicOperatorCode

	// no validation rules for PricingExSourceCurrencyCode

	// no validation rules for PricingExSourceCurrencyBaseRate

	// no validation rules for PricingExTargetCurrencyCode

	// no validation rules for PricingExTargetCurrencyBaseRate

	// no validation rules for PricingExExchangeMarketId

	// no validation rules for PricingExCalculationRate

	// no validation rules for PricingExMathematicOperatorCode

	// no validation rules for PaymentExSourceCurrencyCode

	// no validation rules for PaymentExSourceCurrencyBaseRate

	// no validation rules for PaymentExTargetCurrencyCode

	// no validation rules for PaymentExTargetCurrencyBaseRate

	// no validation rules for PaymentExExchangeMarketId

	// no validation rules for PaymentExCalculationRate

	// no validation rules for PaymentExMathematicOperatorCode

	// no validation rules for PaymentAltExSourceCurrencyCode

	// no validation rules for PaymentAltExSourceCurrencyBaseRate

	// no validation rules for PaymentAltExTargetCurrencyCode

	// no validation rules for PaymentAltExTargetCurrencyBaseRate

	// no validation rules for PaymentAltExExchangeMarketId

	// no validation rules for PaymentAltExCalculationRate

	// no validation rules for PaymentAltExMathematicOperatorCode

	// no validation rules for LineExtensionAmount

	// no validation rules for TaxExclusiveAmount

	// no validation rules for TaxInclusiveAmount

	// no validation rules for AllowanceTotalAmount

	// no validation rules for ChargeTotalAmount

	// no validation rules for WithholdingTaxTotalAmount

	// no validation rules for PrepaidAmount

	// no validation rules for PayableRoundingAmount

	// no validation rules for PayableAmount

	// no validation rules for PayableAlternativeAmount

	if len(errors) > 0 {
		return InvoiceHeaderDMultiError(errors)
	}

	return nil
}

// InvoiceHeaderDMultiError is an error wrapping multiple validation errors
// returned by InvoiceHeaderD.ValidateAll() if the designated constraints
// aren't met.
type InvoiceHeaderDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceHeaderDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceHeaderDMultiError) AllErrors() []error { return m }

// InvoiceHeaderDValidationError is the validation error returned by
// InvoiceHeaderD.Validate if the designated constraints aren't met.
type InvoiceHeaderDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceHeaderDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceHeaderDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceHeaderDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceHeaderDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceHeaderDValidationError) ErrorName() string { return "InvoiceHeaderDValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceHeaderDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceHeaderD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceHeaderDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceHeaderDValidationError{}

// Validate checks the field values on InvoiceHeaderT with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceHeaderT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceHeaderT with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceHeaderTMultiError,
// or nil if none found.
func (m *InvoiceHeaderT) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceHeaderT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIssueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceHeaderTValidationError{
				field:  "IssueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "DueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "DueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceHeaderTValidationError{
				field:  "DueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTaxPointDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "TaxPointDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "TaxPointDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxPointDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceHeaderTValidationError{
				field:  "TaxPointDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvoicePeriodStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "InvoicePeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "InvoicePeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoicePeriodStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceHeaderTValidationError{
				field:  "InvoicePeriodStartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvoicePeriodEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "InvoicePeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "InvoicePeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoicePeriodEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceHeaderTValidationError{
				field:  "InvoicePeriodEndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTaxExDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "TaxExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "TaxExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxExDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceHeaderTValidationError{
				field:  "TaxExDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPricingExDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "PricingExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "PricingExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPricingExDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceHeaderTValidationError{
				field:  "PricingExDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPaymentExDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "PaymentExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "PaymentExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaymentExDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceHeaderTValidationError{
				field:  "PaymentExDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPaymentAltExDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "PaymentAltExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceHeaderTValidationError{
					field:  "PaymentAltExDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaymentAltExDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceHeaderTValidationError{
				field:  "PaymentAltExDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceHeaderTMultiError(errors)
	}

	return nil
}

// InvoiceHeaderTMultiError is an error wrapping multiple validation errors
// returned by InvoiceHeaderT.ValidateAll() if the designated constraints
// aren't met.
type InvoiceHeaderTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceHeaderTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceHeaderTMultiError) AllErrors() []error { return m }

// InvoiceHeaderTValidationError is the validation error returned by
// InvoiceHeaderT.Validate if the designated constraints aren't met.
type InvoiceHeaderTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceHeaderTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceHeaderTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceHeaderTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceHeaderTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceHeaderTValidationError) ErrorName() string { return "InvoiceHeaderTValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceHeaderTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceHeaderT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceHeaderTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceHeaderTValidationError{}

// Validate checks the field values on CreateInvoiceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInvoiceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvoiceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInvoiceRequestMultiError, or nil if none found.
func (m *CreateInvoiceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvoiceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IhId

	// no validation rules for IssueDate

	// no validation rules for DueDate

	// no validation rules for TaxPointDate

	// no validation rules for InvoicePeriodStartDate

	// no validation rules for InvoicePeriodEndDate

	// no validation rules for InvoiceTypeCode

	// no validation rules for Note

	// no validation rules for DocumentCurrencyCode

	// no validation rules for TaxCurrencyCode

	// no validation rules for PricingCurrencyCode

	// no validation rules for PaymentCurrencyCode

	// no validation rules for PaymentAltCurrencyCode

	// no validation rules for AccountingCostCode

	// no validation rules for AccountingCost

	// no validation rules for LineCountNumeric

	// no validation rules for OrderId

	// no validation rules for BillingId

	// no validation rules for DespatchId

	// no validation rules for ReceiptId

	// no validation rules for StatementId

	// no validation rules for ContractId

	// no validation rules for AccountingSupplierPartyId

	// no validation rules for AccountingCustomerPartyId

	// no validation rules for PayeePartyId

	// no validation rules for BuyerCustomerPartyId

	// no validation rules for SellerSupplierPartyId

	// no validation rules for TaxRepresentativePartyId

	// no validation rules for TaxExSourceCurrencyCode

	// no validation rules for TaxExSourceCurrencyBaseRate

	// no validation rules for TaxExTargetCurrencyCode

	// no validation rules for TaxExTargetCurrencyBaseRate

	// no validation rules for TaxExExchangeMarketId

	// no validation rules for TaxExCalculationRate

	// no validation rules for TaxExMathematicOperatorCode

	// no validation rules for TaxExDate

	// no validation rules for PricingExSourceCurrencyCode

	// no validation rules for PricingExSourceCurrencyBaseRate

	// no validation rules for PricingExTargetCurrencyCode

	// no validation rules for PricingExTargetCurrencyBaseRate

	// no validation rules for PricingExExchangeMarketId

	// no validation rules for PricingExCalculationRate

	// no validation rules for PricingExMathematicOperatorCode

	// no validation rules for PricingExDate

	// no validation rules for PaymentExSourceCurrencyCode

	// no validation rules for PaymentExSourceCurrencyBaseRate

	// no validation rules for PaymentExTargetCurrencyCode

	// no validation rules for PaymentExTargetCurrencyBaseRate

	// no validation rules for PaymentExExchangeMarketId

	// no validation rules for PaymentExCalculationRate

	// no validation rules for PaymentExMathematicOperatorCode

	// no validation rules for PaymentExDate

	// no validation rules for PaymentAltExSourceCurrencyCode

	// no validation rules for PaymentAltExSourceCurrencyBaseRate

	// no validation rules for PaymentAltExTargetCurrencyCode

	// no validation rules for PaymentAltExTargetCurrencyBaseRate

	// no validation rules for PaymentAltExExchangeMarketId

	// no validation rules for PaymentAltExCalculationRate

	// no validation rules for PaymentAltExMathematicOperatorCode

	// no validation rules for PaymentAltExDate

	// no validation rules for LineExtensionAmount

	// no validation rules for TaxExclusiveAmount

	// no validation rules for TaxInclusiveAmount

	// no validation rules for AllowanceTotalAmount

	// no validation rules for ChargeTotalAmount

	// no validation rules for WithholdingTaxTotalAmount

	// no validation rules for PrepaidAmount

	// no validation rules for PayableRoundingAmount

	// no validation rules for PayableAmount

	// no validation rules for PayableAlternativeAmount

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	for idx, item := range m.GetInvoiceLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateInvoiceRequestValidationError{
						field:  fmt.Sprintf("InvoiceLines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateInvoiceRequestValidationError{
						field:  fmt.Sprintf("InvoiceLines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateInvoiceRequestValidationError{
					field:  fmt.Sprintf("InvoiceLines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateInvoiceRequestMultiError(errors)
	}

	return nil
}

// CreateInvoiceRequestMultiError is an error wrapping multiple validation
// errors returned by CreateInvoiceRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateInvoiceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvoiceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvoiceRequestMultiError) AllErrors() []error { return m }

// CreateInvoiceRequestValidationError is the validation error returned by
// CreateInvoiceRequest.Validate if the designated constraints aren't met.
type CreateInvoiceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvoiceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvoiceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvoiceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvoiceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvoiceRequestValidationError) ErrorName() string {
	return "CreateInvoiceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvoiceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvoiceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvoiceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvoiceRequestValidationError{}

// Validate checks the field values on CreateInvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInvoiceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInvoiceResponseMultiError, or nil if none found.
func (m *CreateInvoiceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvoiceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoiceHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInvoiceResponseValidationError{
					field:  "InvoiceHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInvoiceResponseValidationError{
					field:  "InvoiceHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInvoiceResponseValidationError{
				field:  "InvoiceHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInvoiceResponseMultiError(errors)
	}

	return nil
}

// CreateInvoiceResponseMultiError is an error wrapping multiple validation
// errors returned by CreateInvoiceResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateInvoiceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvoiceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvoiceResponseMultiError) AllErrors() []error { return m }

// CreateInvoiceResponseValidationError is the validation error returned by
// CreateInvoiceResponse.Validate if the designated constraints aren't met.
type CreateInvoiceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvoiceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvoiceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvoiceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvoiceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvoiceResponseValidationError) ErrorName() string {
	return "CreateInvoiceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvoiceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvoiceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvoiceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvoiceResponseValidationError{}

// Validate checks the field values on UpdateInvoiceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateInvoiceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateInvoiceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateInvoiceRequestMultiError, or nil if none found.
func (m *UpdateInvoiceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateInvoiceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Note

	// no validation rules for InvoiceTypeCode

	// no validation rules for AccountingCost

	// no validation rules for ChargeTotalAmount

	// no validation rules for PrepaidAmount

	// no validation rules for PayableRoundingAmount

	// no validation rules for PayableAmount

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return UpdateInvoiceRequestMultiError(errors)
	}

	return nil
}

// UpdateInvoiceRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateInvoiceRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateInvoiceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateInvoiceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateInvoiceRequestMultiError) AllErrors() []error { return m }

// UpdateInvoiceRequestValidationError is the validation error returned by
// UpdateInvoiceRequest.Validate if the designated constraints aren't met.
type UpdateInvoiceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateInvoiceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateInvoiceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateInvoiceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateInvoiceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateInvoiceRequestValidationError) ErrorName() string {
	return "UpdateInvoiceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateInvoiceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateInvoiceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateInvoiceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateInvoiceRequestValidationError{}

// Validate checks the field values on UpdateInvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateInvoiceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateInvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateInvoiceResponseMultiError, or nil if none found.
func (m *UpdateInvoiceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateInvoiceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateInvoiceResponseMultiError(errors)
	}

	return nil
}

// UpdateInvoiceResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateInvoiceResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateInvoiceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateInvoiceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateInvoiceResponseMultiError) AllErrors() []error { return m }

// UpdateInvoiceResponseValidationError is the validation error returned by
// UpdateInvoiceResponse.Validate if the designated constraints aren't met.
type UpdateInvoiceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateInvoiceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateInvoiceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateInvoiceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateInvoiceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateInvoiceResponseValidationError) ErrorName() string {
	return "UpdateInvoiceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateInvoiceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateInvoiceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateInvoiceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateInvoiceResponseValidationError{}

// Validate checks the field values on GetInvoiceRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetInvoiceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoiceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoiceRequestMultiError, or nil if none found.
func (m *GetInvoiceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoiceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInvoiceRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInvoiceRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInvoiceRequestValidationError{
				field:  "GetRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInvoiceRequestMultiError(errors)
	}

	return nil
}

// GetInvoiceRequestMultiError is an error wrapping multiple validation errors
// returned by GetInvoiceRequest.ValidateAll() if the designated constraints
// aren't met.
type GetInvoiceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoiceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoiceRequestMultiError) AllErrors() []error { return m }

// GetInvoiceRequestValidationError is the validation error returned by
// GetInvoiceRequest.Validate if the designated constraints aren't met.
type GetInvoiceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoiceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoiceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoiceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoiceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoiceRequestValidationError) ErrorName() string {
	return "GetInvoiceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoiceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoiceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoiceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoiceRequestValidationError{}

// Validate checks the field values on GetInvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvoiceResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoiceResponseMultiError, or nil if none found.
func (m *GetInvoiceResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoiceResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoiceHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInvoiceResponseValidationError{
					field:  "InvoiceHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInvoiceResponseValidationError{
					field:  "InvoiceHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInvoiceResponseValidationError{
				field:  "InvoiceHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInvoiceResponseMultiError(errors)
	}

	return nil
}

// GetInvoiceResponseMultiError is an error wrapping multiple validation errors
// returned by GetInvoiceResponse.ValidateAll() if the designated constraints
// aren't met.
type GetInvoiceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoiceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoiceResponseMultiError) AllErrors() []error { return m }

// GetInvoiceResponseValidationError is the validation error returned by
// GetInvoiceResponse.Validate if the designated constraints aren't met.
type GetInvoiceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoiceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoiceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoiceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoiceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoiceResponseValidationError) ErrorName() string {
	return "GetInvoiceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoiceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoiceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoiceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoiceResponseValidationError{}

// Validate checks the field values on GetInvoiceByPkRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvoiceByPkRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoiceByPkRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoiceByPkRequestMultiError, or nil if none found.
func (m *GetInvoiceByPkRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoiceByPkRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetByIdRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInvoiceByPkRequestValidationError{
					field:  "GetByIdRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInvoiceByPkRequestValidationError{
					field:  "GetByIdRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetByIdRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInvoiceByPkRequestValidationError{
				field:  "GetByIdRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInvoiceByPkRequestMultiError(errors)
	}

	return nil
}

// GetInvoiceByPkRequestMultiError is an error wrapping multiple validation
// errors returned by GetInvoiceByPkRequest.ValidateAll() if the designated
// constraints aren't met.
type GetInvoiceByPkRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoiceByPkRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoiceByPkRequestMultiError) AllErrors() []error { return m }

// GetInvoiceByPkRequestValidationError is the validation error returned by
// GetInvoiceByPkRequest.Validate if the designated constraints aren't met.
type GetInvoiceByPkRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoiceByPkRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoiceByPkRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoiceByPkRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoiceByPkRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoiceByPkRequestValidationError) ErrorName() string {
	return "GetInvoiceByPkRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoiceByPkRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoiceByPkRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoiceByPkRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoiceByPkRequestValidationError{}

// Validate checks the field values on GetInvoiceByPkResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvoiceByPkResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoiceByPkResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoiceByPkResponseMultiError, or nil if none found.
func (m *GetInvoiceByPkResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoiceByPkResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoiceHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInvoiceByPkResponseValidationError{
					field:  "InvoiceHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInvoiceByPkResponseValidationError{
					field:  "InvoiceHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInvoiceByPkResponseValidationError{
				field:  "InvoiceHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInvoiceByPkResponseMultiError(errors)
	}

	return nil
}

// GetInvoiceByPkResponseMultiError is an error wrapping multiple validation
// errors returned by GetInvoiceByPkResponse.ValidateAll() if the designated
// constraints aren't met.
type GetInvoiceByPkResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoiceByPkResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoiceByPkResponseMultiError) AllErrors() []error { return m }

// GetInvoiceByPkResponseValidationError is the validation error returned by
// GetInvoiceByPkResponse.Validate if the designated constraints aren't met.
type GetInvoiceByPkResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoiceByPkResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoiceByPkResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoiceByPkResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoiceByPkResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoiceByPkResponseValidationError) ErrorName() string {
	return "GetInvoiceByPkResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoiceByPkResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoiceByPkResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoiceByPkResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoiceByPkResponseValidationError{}

// Validate checks the field values on GetInvoicesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvoicesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoicesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoicesRequestMultiError, or nil if none found.
func (m *GetInvoicesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoicesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for NextCursor

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetInvoicesRequestMultiError(errors)
	}

	return nil
}

// GetInvoicesRequestMultiError is an error wrapping multiple validation errors
// returned by GetInvoicesRequest.ValidateAll() if the designated constraints
// aren't met.
type GetInvoicesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoicesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoicesRequestMultiError) AllErrors() []error { return m }

// GetInvoicesRequestValidationError is the validation error returned by
// GetInvoicesRequest.Validate if the designated constraints aren't met.
type GetInvoicesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoicesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoicesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoicesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoicesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoicesRequestValidationError) ErrorName() string {
	return "GetInvoicesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoicesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoicesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoicesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoicesRequestValidationError{}

// Validate checks the field values on GetInvoicesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvoicesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoicesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoicesResponseMultiError, or nil if none found.
func (m *GetInvoicesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoicesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInvoiceHeaders() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetInvoicesResponseValidationError{
						field:  fmt.Sprintf("InvoiceHeaders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetInvoicesResponseValidationError{
						field:  fmt.Sprintf("InvoiceHeaders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetInvoicesResponseValidationError{
					field:  fmt.Sprintf("InvoiceHeaders[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextCursor

	if len(errors) > 0 {
		return GetInvoicesResponseMultiError(errors)
	}

	return nil
}

// GetInvoicesResponseMultiError is an error wrapping multiple validation
// errors returned by GetInvoicesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetInvoicesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoicesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoicesResponseMultiError) AllErrors() []error { return m }

// GetInvoicesResponseValidationError is the validation error returned by
// GetInvoicesResponse.Validate if the designated constraints aren't met.
type GetInvoicesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoicesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoicesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoicesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoicesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoicesResponseValidationError) ErrorName() string {
	return "GetInvoicesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoicesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoicesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoicesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoicesResponseValidationError{}

// Validate checks the field values on InvoiceLine with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceLine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceLine with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceLineMultiError, or
// nil if none found.
func (m *InvoiceLine) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceLine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoiceLineD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineValidationError{
					field:  "InvoiceLineD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineValidationError{
					field:  "InvoiceLineD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceLineD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineValidationError{
				field:  "InvoiceLineD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvoiceLineT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineValidationError{
					field:  "InvoiceLineT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineValidationError{
					field:  "InvoiceLineT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceLineT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineValidationError{
				field:  "InvoiceLineT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceLineMultiError(errors)
	}

	return nil
}

// InvoiceLineMultiError is an error wrapping multiple validation errors
// returned by InvoiceLine.ValidateAll() if the designated constraints aren't met.
type InvoiceLineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceLineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceLineMultiError) AllErrors() []error { return m }

// InvoiceLineValidationError is the validation error returned by
// InvoiceLine.Validate if the designated constraints aren't met.
type InvoiceLineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceLineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceLineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceLineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceLineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceLineValidationError) ErrorName() string { return "InvoiceLineValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceLineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceLine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceLineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceLineValidationError{}

// Validate checks the field values on InvoiceLineD with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceLineD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceLineD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceLineDMultiError, or
// nil if none found.
func (m *InvoiceLineD) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceLineD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for IlId

	// no validation rules for Note

	// no validation rules for InvoicedQuantity

	// no validation rules for LineExtensionAmount

	// no validation rules for AccountingCostCode

	// no validation rules for AccountingCost

	// no validation rules for PaymentPurposeCode

	// no validation rules for FreeOfChargeIndicator

	// no validation rules for OrderLineId

	// no validation rules for DespatchLineId

	// no validation rules for ReceiptLineId

	// no validation rules for BillingId

	// no validation rules for OriginatorPartyId

	// no validation rules for ItemId

	// no validation rules for PriceAmount

	// no validation rules for PriceBaseQuantity

	// no validation rules for PriceChangeReason

	// no validation rules for PriceTypeCode

	// no validation rules for PriceType

	// no validation rules for OrderableUnitFactorRate

	// no validation rules for PriceListId

	// no validation rules for InvoiceHeaderId

	if len(errors) > 0 {
		return InvoiceLineDMultiError(errors)
	}

	return nil
}

// InvoiceLineDMultiError is an error wrapping multiple validation errors
// returned by InvoiceLineD.ValidateAll() if the designated constraints aren't met.
type InvoiceLineDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceLineDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceLineDMultiError) AllErrors() []error { return m }

// InvoiceLineDValidationError is the validation error returned by
// InvoiceLineD.Validate if the designated constraints aren't met.
type InvoiceLineDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceLineDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceLineDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceLineDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceLineDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceLineDValidationError) ErrorName() string { return "InvoiceLineDValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceLineDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceLineD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceLineDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceLineDValidationError{}

// Validate checks the field values on InvoiceLineT with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceLineT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceLineT with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceLineTMultiError, or
// nil if none found.
func (m *InvoiceLineT) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceLineT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTaxPointDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineTValidationError{
					field:  "TaxPointDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineTValidationError{
					field:  "TaxPointDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTaxPointDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineTValidationError{
				field:  "TaxPointDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvoicePeriodStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineTValidationError{
					field:  "InvoicePeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineTValidationError{
					field:  "InvoicePeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoicePeriodStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineTValidationError{
				field:  "InvoicePeriodStartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInvoicePeriodEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineTValidationError{
					field:  "InvoicePeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineTValidationError{
					field:  "InvoicePeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoicePeriodEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineTValidationError{
				field:  "InvoicePeriodEndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPriceValidityPeriodStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineTValidationError{
					field:  "PriceValidityPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineTValidationError{
					field:  "PriceValidityPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPriceValidityPeriodStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineTValidationError{
				field:  "PriceValidityPeriodStartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPriceValidityPeriodEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InvoiceLineTValidationError{
					field:  "PriceValidityPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InvoiceLineTValidationError{
					field:  "PriceValidityPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPriceValidityPeriodEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InvoiceLineTValidationError{
				field:  "PriceValidityPeriodEndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InvoiceLineTMultiError(errors)
	}

	return nil
}

// InvoiceLineTMultiError is an error wrapping multiple validation errors
// returned by InvoiceLineT.ValidateAll() if the designated constraints aren't met.
type InvoiceLineTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceLineTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceLineTMultiError) AllErrors() []error { return m }

// InvoiceLineTValidationError is the validation error returned by
// InvoiceLineT.Validate if the designated constraints aren't met.
type InvoiceLineTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceLineTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceLineTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceLineTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceLineTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceLineTValidationError) ErrorName() string { return "InvoiceLineTValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceLineTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceLineT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceLineTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceLineTValidationError{}

// Validate checks the field values on CreateInvoiceLineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInvoiceLineRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvoiceLineRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInvoiceLineRequestMultiError, or nil if none found.
func (m *CreateInvoiceLineRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvoiceLineRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IlId

	// no validation rules for Note

	// no validation rules for InvoicedQuantity

	// no validation rules for LineExtensionAmount

	// no validation rules for TaxPointDate

	// no validation rules for AccountingCostCode

	// no validation rules for AccountingCost

	// no validation rules for PaymentPurposeCode

	// no validation rules for FreeOfChargeIndicator

	// no validation rules for InvoicePeriodStartDate

	// no validation rules for InvoicePeriodEndDate

	// no validation rules for OrderLineId

	// no validation rules for DespatchLineId

	// no validation rules for ReceiptLineId

	// no validation rules for BillingId

	// no validation rules for OriginatorPartyId

	// no validation rules for ItemId

	// no validation rules for PriceAmount

	// no validation rules for PriceBaseQuantity

	// no validation rules for PriceChangeReason

	// no validation rules for PriceTypeCode

	// no validation rules for PriceType

	// no validation rules for OrderableUnitFactorRate

	// no validation rules for PriceValidityPeriodStartDate

	// no validation rules for PriceValidityPeriodEndDate

	// no validation rules for PriceListId

	// no validation rules for InvoiceHeaderId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateInvoiceLineRequestMultiError(errors)
	}

	return nil
}

// CreateInvoiceLineRequestMultiError is an error wrapping multiple validation
// errors returned by CreateInvoiceLineRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateInvoiceLineRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvoiceLineRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvoiceLineRequestMultiError) AllErrors() []error { return m }

// CreateInvoiceLineRequestValidationError is the validation error returned by
// CreateInvoiceLineRequest.Validate if the designated constraints aren't met.
type CreateInvoiceLineRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvoiceLineRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvoiceLineRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvoiceLineRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvoiceLineRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvoiceLineRequestValidationError) ErrorName() string {
	return "CreateInvoiceLineRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvoiceLineRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvoiceLineRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvoiceLineRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvoiceLineRequestValidationError{}

// Validate checks the field values on CreateInvoiceLineResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateInvoiceLineResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateInvoiceLineResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateInvoiceLineResponseMultiError, or nil if none found.
func (m *CreateInvoiceLineResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateInvoiceLineResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInvoiceLine()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateInvoiceLineResponseValidationError{
					field:  "InvoiceLine",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateInvoiceLineResponseValidationError{
					field:  "InvoiceLine",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInvoiceLine()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateInvoiceLineResponseValidationError{
				field:  "InvoiceLine",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateInvoiceLineResponseMultiError(errors)
	}

	return nil
}

// CreateInvoiceLineResponseMultiError is an error wrapping multiple validation
// errors returned by CreateInvoiceLineResponse.ValidateAll() if the
// designated constraints aren't met.
type CreateInvoiceLineResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInvoiceLineResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInvoiceLineResponseMultiError) AllErrors() []error { return m }

// CreateInvoiceLineResponseValidationError is the validation error returned by
// CreateInvoiceLineResponse.Validate if the designated constraints aren't met.
type CreateInvoiceLineResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInvoiceLineResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInvoiceLineResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInvoiceLineResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInvoiceLineResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInvoiceLineResponseValidationError) ErrorName() string {
	return "CreateInvoiceLineResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInvoiceLineResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInvoiceLineResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInvoiceLineResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInvoiceLineResponseValidationError{}

// Validate checks the field values on GetInvoiceLinesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvoiceLinesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoiceLinesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoiceLinesRequestMultiError, or nil if none found.
func (m *GetInvoiceLinesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoiceLinesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetInvoiceLinesRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetInvoiceLinesRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetInvoiceLinesRequestValidationError{
				field:  "GetRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetInvoiceLinesRequestMultiError(errors)
	}

	return nil
}

// GetInvoiceLinesRequestMultiError is an error wrapping multiple validation
// errors returned by GetInvoiceLinesRequest.ValidateAll() if the designated
// constraints aren't met.
type GetInvoiceLinesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoiceLinesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoiceLinesRequestMultiError) AllErrors() []error { return m }

// GetInvoiceLinesRequestValidationError is the validation error returned by
// GetInvoiceLinesRequest.Validate if the designated constraints aren't met.
type GetInvoiceLinesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoiceLinesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoiceLinesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoiceLinesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoiceLinesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoiceLinesRequestValidationError) ErrorName() string {
	return "GetInvoiceLinesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoiceLinesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoiceLinesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoiceLinesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoiceLinesRequestValidationError{}

// Validate checks the field values on GetInvoiceLinesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetInvoiceLinesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetInvoiceLinesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetInvoiceLinesResponseMultiError, or nil if none found.
func (m *GetInvoiceLinesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetInvoiceLinesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInvoiceLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetInvoiceLinesResponseValidationError{
						field:  fmt.Sprintf("InvoiceLines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetInvoiceLinesResponseValidationError{
						field:  fmt.Sprintf("InvoiceLines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetInvoiceLinesResponseValidationError{
					field:  fmt.Sprintf("InvoiceLines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetInvoiceLinesResponseMultiError(errors)
	}

	return nil
}

// GetInvoiceLinesResponseMultiError is an error wrapping multiple validation
// errors returned by GetInvoiceLinesResponse.ValidateAll() if the designated
// constraints aren't met.
type GetInvoiceLinesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetInvoiceLinesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetInvoiceLinesResponseMultiError) AllErrors() []error { return m }

// GetInvoiceLinesResponseValidationError is the validation error returned by
// GetInvoiceLinesResponse.Validate if the designated constraints aren't met.
type GetInvoiceLinesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetInvoiceLinesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetInvoiceLinesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetInvoiceLinesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetInvoiceLinesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetInvoiceLinesResponseValidationError) ErrorName() string {
	return "GetInvoiceLinesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetInvoiceLinesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetInvoiceLinesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetInvoiceLinesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetInvoiceLinesResponseValidationError{}

// Validate checks the field values on InvoiceLines with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InvoiceLines) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InvoiceLines with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InvoiceLinesMultiError, or
// nil if none found.
func (m *InvoiceLines) ValidateAll() error {
	return m.validate(true)
}

func (m *InvoiceLines) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetInvoiceLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InvoiceLinesValidationError{
						field:  fmt.Sprintf("InvoiceLines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InvoiceLinesValidationError{
						field:  fmt.Sprintf("InvoiceLines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InvoiceLinesValidationError{
					field:  fmt.Sprintf("InvoiceLines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return InvoiceLinesMultiError(errors)
	}

	return nil
}

// InvoiceLinesMultiError is an error wrapping multiple validation errors
// returned by InvoiceLines.ValidateAll() if the designated constraints aren't met.
type InvoiceLinesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InvoiceLinesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InvoiceLinesMultiError) AllErrors() []error { return m }

// InvoiceLinesValidationError is the validation error returned by
// InvoiceLines.Validate if the designated constraints aren't met.
type InvoiceLinesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvoiceLinesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvoiceLinesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvoiceLinesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvoiceLinesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvoiceLinesValidationError) ErrorName() string { return "InvoiceLinesValidationError" }

// Error satisfies the builtin error interface
func (e InvoiceLinesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvoiceLines.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvoiceLinesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvoiceLinesValidationError{}
