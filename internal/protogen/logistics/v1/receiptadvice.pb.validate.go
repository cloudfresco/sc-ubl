// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: logistics/v1/receiptadvice.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ReceiptAdviceHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReceiptAdviceHeader) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceiptAdviceHeader with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReceiptAdviceHeaderMultiError, or nil if none found.
func (m *ReceiptAdviceHeader) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceiptAdviceHeader) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReceiptAdviceHeaderD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReceiptAdviceHeaderValidationError{
					field:  "ReceiptAdviceHeaderD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReceiptAdviceHeaderValidationError{
					field:  "ReceiptAdviceHeaderD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReceiptAdviceHeaderD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReceiptAdviceHeaderValidationError{
				field:  "ReceiptAdviceHeaderD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReceiptAdviceHeaderT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReceiptAdviceHeaderValidationError{
					field:  "ReceiptAdviceHeaderT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReceiptAdviceHeaderValidationError{
					field:  "ReceiptAdviceHeaderT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReceiptAdviceHeaderT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReceiptAdviceHeaderValidationError{
				field:  "ReceiptAdviceHeaderT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReceiptAdviceHeaderValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReceiptAdviceHeaderValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReceiptAdviceHeaderValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReceiptAdviceHeaderValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReceiptAdviceHeaderValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReceiptAdviceHeaderValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReceiptAdviceHeaderMultiError(errors)
	}

	return nil
}

// ReceiptAdviceHeaderMultiError is an error wrapping multiple validation
// errors returned by ReceiptAdviceHeader.ValidateAll() if the designated
// constraints aren't met.
type ReceiptAdviceHeaderMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceiptAdviceHeaderMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceiptAdviceHeaderMultiError) AllErrors() []error { return m }

// ReceiptAdviceHeaderValidationError is the validation error returned by
// ReceiptAdviceHeader.Validate if the designated constraints aren't met.
type ReceiptAdviceHeaderValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceiptAdviceHeaderValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceiptAdviceHeaderValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceiptAdviceHeaderValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceiptAdviceHeaderValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceiptAdviceHeaderValidationError) ErrorName() string {
	return "ReceiptAdviceHeaderValidationError"
}

// Error satisfies the builtin error interface
func (e ReceiptAdviceHeaderValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceiptAdviceHeader.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceiptAdviceHeaderValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceiptAdviceHeaderValidationError{}

// Validate checks the field values on ReceiptAdviceHeaderD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReceiptAdviceHeaderD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceiptAdviceHeaderD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReceiptAdviceHeaderDMultiError, or nil if none found.
func (m *ReceiptAdviceHeaderD) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceiptAdviceHeaderD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for RcpthId

	// no validation rules for ReceiptAdviceTypeCode

	// no validation rules for Note

	// no validation rules for LineCountNumeric

	// no validation rules for OrderId

	// no validation rules for DespatchId

	// no validation rules for DeliveryCustomerPartyId

	// no validation rules for DespatchSupplierPartyId

	// no validation rules for BuyerCustomerPartyId

	// no validation rules for SellerSupplierPartyId

	// no validation rules for ShipmentId

	if len(errors) > 0 {
		return ReceiptAdviceHeaderDMultiError(errors)
	}

	return nil
}

// ReceiptAdviceHeaderDMultiError is an error wrapping multiple validation
// errors returned by ReceiptAdviceHeaderD.ValidateAll() if the designated
// constraints aren't met.
type ReceiptAdviceHeaderDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceiptAdviceHeaderDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceiptAdviceHeaderDMultiError) AllErrors() []error { return m }

// ReceiptAdviceHeaderDValidationError is the validation error returned by
// ReceiptAdviceHeaderD.Validate if the designated constraints aren't met.
type ReceiptAdviceHeaderDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceiptAdviceHeaderDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceiptAdviceHeaderDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceiptAdviceHeaderDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceiptAdviceHeaderDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceiptAdviceHeaderDValidationError) ErrorName() string {
	return "ReceiptAdviceHeaderDValidationError"
}

// Error satisfies the builtin error interface
func (e ReceiptAdviceHeaderDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceiptAdviceHeaderD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceiptAdviceHeaderDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceiptAdviceHeaderDValidationError{}

// Validate checks the field values on ReceiptAdviceHeaderT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReceiptAdviceHeaderT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceiptAdviceHeaderT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReceiptAdviceHeaderTMultiError, or nil if none found.
func (m *ReceiptAdviceHeaderT) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceiptAdviceHeaderT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIssueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReceiptAdviceHeaderTValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReceiptAdviceHeaderTValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReceiptAdviceHeaderTValidationError{
				field:  "IssueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReceiptAdviceHeaderTMultiError(errors)
	}

	return nil
}

// ReceiptAdviceHeaderTMultiError is an error wrapping multiple validation
// errors returned by ReceiptAdviceHeaderT.ValidateAll() if the designated
// constraints aren't met.
type ReceiptAdviceHeaderTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceiptAdviceHeaderTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceiptAdviceHeaderTMultiError) AllErrors() []error { return m }

// ReceiptAdviceHeaderTValidationError is the validation error returned by
// ReceiptAdviceHeaderT.Validate if the designated constraints aren't met.
type ReceiptAdviceHeaderTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceiptAdviceHeaderTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceiptAdviceHeaderTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceiptAdviceHeaderTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceiptAdviceHeaderTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceiptAdviceHeaderTValidationError) ErrorName() string {
	return "ReceiptAdviceHeaderTValidationError"
}

// Error satisfies the builtin error interface
func (e ReceiptAdviceHeaderTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceiptAdviceHeaderT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceiptAdviceHeaderTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceiptAdviceHeaderTValidationError{}

// Validate checks the field values on CreateReceiptAdviceHeaderRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateReceiptAdviceHeaderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateReceiptAdviceHeaderRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateReceiptAdviceHeaderRequestMultiError, or nil if none found.
func (m *CreateReceiptAdviceHeaderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReceiptAdviceHeaderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RcpthId

	// no validation rules for IssueDate

	// no validation rules for ReceiptAdviceTypeCode

	// no validation rules for Note

	// no validation rules for LineCountNumeric

	// no validation rules for OrderId

	// no validation rules for DespatchId

	// no validation rules for DeliveryCustomerPartyId

	// no validation rules for DespatchSupplierPartyId

	// no validation rules for BuyerCustomerPartyId

	// no validation rules for SellerSupplierPartyId

	// no validation rules for ShipmentId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	for idx, item := range m.GetReceiptAdviceLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateReceiptAdviceHeaderRequestValidationError{
						field:  fmt.Sprintf("ReceiptAdviceLines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateReceiptAdviceHeaderRequestValidationError{
						field:  fmt.Sprintf("ReceiptAdviceLines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateReceiptAdviceHeaderRequestValidationError{
					field:  fmt.Sprintf("ReceiptAdviceLines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateReceiptAdviceHeaderRequestMultiError(errors)
	}

	return nil
}

// CreateReceiptAdviceHeaderRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateReceiptAdviceHeaderRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateReceiptAdviceHeaderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReceiptAdviceHeaderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReceiptAdviceHeaderRequestMultiError) AllErrors() []error { return m }

// CreateReceiptAdviceHeaderRequestValidationError is the validation error
// returned by CreateReceiptAdviceHeaderRequest.Validate if the designated
// constraints aren't met.
type CreateReceiptAdviceHeaderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReceiptAdviceHeaderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReceiptAdviceHeaderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateReceiptAdviceHeaderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReceiptAdviceHeaderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReceiptAdviceHeaderRequestValidationError) ErrorName() string {
	return "CreateReceiptAdviceHeaderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateReceiptAdviceHeaderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReceiptAdviceHeaderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReceiptAdviceHeaderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReceiptAdviceHeaderRequestValidationError{}

// Validate checks the field values on CreateReceiptAdviceHeaderResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateReceiptAdviceHeaderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateReceiptAdviceHeaderResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateReceiptAdviceHeaderResponseMultiError, or nil if none found.
func (m *CreateReceiptAdviceHeaderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReceiptAdviceHeaderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReceiptAdviceHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateReceiptAdviceHeaderResponseValidationError{
					field:  "ReceiptAdviceHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateReceiptAdviceHeaderResponseValidationError{
					field:  "ReceiptAdviceHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReceiptAdviceHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateReceiptAdviceHeaderResponseValidationError{
				field:  "ReceiptAdviceHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateReceiptAdviceHeaderResponseMultiError(errors)
	}

	return nil
}

// CreateReceiptAdviceHeaderResponseMultiError is an error wrapping multiple
// validation errors returned by
// CreateReceiptAdviceHeaderResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateReceiptAdviceHeaderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReceiptAdviceHeaderResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReceiptAdviceHeaderResponseMultiError) AllErrors() []error { return m }

// CreateReceiptAdviceHeaderResponseValidationError is the validation error
// returned by CreateReceiptAdviceHeaderResponse.Validate if the designated
// constraints aren't met.
type CreateReceiptAdviceHeaderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReceiptAdviceHeaderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReceiptAdviceHeaderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateReceiptAdviceHeaderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReceiptAdviceHeaderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReceiptAdviceHeaderResponseValidationError) ErrorName() string {
	return "CreateReceiptAdviceHeaderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateReceiptAdviceHeaderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReceiptAdviceHeaderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReceiptAdviceHeaderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReceiptAdviceHeaderResponseValidationError{}

// Validate checks the field values on GetReceiptAdviceHeaderRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReceiptAdviceHeaderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReceiptAdviceHeaderRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetReceiptAdviceHeaderRequestMultiError, or nil if none found.
func (m *GetReceiptAdviceHeaderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReceiptAdviceHeaderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReceiptAdviceHeaderRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReceiptAdviceHeaderRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReceiptAdviceHeaderRequestValidationError{
				field:  "GetRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetReceiptAdviceHeaderRequestMultiError(errors)
	}

	return nil
}

// GetReceiptAdviceHeaderRequestMultiError is an error wrapping multiple
// validation errors returned by GetReceiptAdviceHeaderRequest.ValidateAll()
// if the designated constraints aren't met.
type GetReceiptAdviceHeaderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReceiptAdviceHeaderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReceiptAdviceHeaderRequestMultiError) AllErrors() []error { return m }

// GetReceiptAdviceHeaderRequestValidationError is the validation error
// returned by GetReceiptAdviceHeaderRequest.Validate if the designated
// constraints aren't met.
type GetReceiptAdviceHeaderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReceiptAdviceHeaderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReceiptAdviceHeaderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReceiptAdviceHeaderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReceiptAdviceHeaderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReceiptAdviceHeaderRequestValidationError) ErrorName() string {
	return "GetReceiptAdviceHeaderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetReceiptAdviceHeaderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReceiptAdviceHeaderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReceiptAdviceHeaderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReceiptAdviceHeaderRequestValidationError{}

// Validate checks the field values on GetReceiptAdviceHeaderResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReceiptAdviceHeaderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReceiptAdviceHeaderResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetReceiptAdviceHeaderResponseMultiError, or nil if none found.
func (m *GetReceiptAdviceHeaderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReceiptAdviceHeaderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReceiptAdviceHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReceiptAdviceHeaderResponseValidationError{
					field:  "ReceiptAdviceHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReceiptAdviceHeaderResponseValidationError{
					field:  "ReceiptAdviceHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReceiptAdviceHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReceiptAdviceHeaderResponseValidationError{
				field:  "ReceiptAdviceHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetReceiptAdviceHeaderResponseMultiError(errors)
	}

	return nil
}

// GetReceiptAdviceHeaderResponseMultiError is an error wrapping multiple
// validation errors returned by GetReceiptAdviceHeaderResponse.ValidateAll()
// if the designated constraints aren't met.
type GetReceiptAdviceHeaderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReceiptAdviceHeaderResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReceiptAdviceHeaderResponseMultiError) AllErrors() []error { return m }

// GetReceiptAdviceHeaderResponseValidationError is the validation error
// returned by GetReceiptAdviceHeaderResponse.Validate if the designated
// constraints aren't met.
type GetReceiptAdviceHeaderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReceiptAdviceHeaderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReceiptAdviceHeaderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReceiptAdviceHeaderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReceiptAdviceHeaderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReceiptAdviceHeaderResponseValidationError) ErrorName() string {
	return "GetReceiptAdviceHeaderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetReceiptAdviceHeaderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReceiptAdviceHeaderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReceiptAdviceHeaderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReceiptAdviceHeaderResponseValidationError{}

// Validate checks the field values on GetReceiptAdviceHeaderByPkRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetReceiptAdviceHeaderByPkRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReceiptAdviceHeaderByPkRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetReceiptAdviceHeaderByPkRequestMultiError, or nil if none found.
func (m *GetReceiptAdviceHeaderByPkRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReceiptAdviceHeaderByPkRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetByIdRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReceiptAdviceHeaderByPkRequestValidationError{
					field:  "GetByIdRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReceiptAdviceHeaderByPkRequestValidationError{
					field:  "GetByIdRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetByIdRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReceiptAdviceHeaderByPkRequestValidationError{
				field:  "GetByIdRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetReceiptAdviceHeaderByPkRequestMultiError(errors)
	}

	return nil
}

// GetReceiptAdviceHeaderByPkRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetReceiptAdviceHeaderByPkRequest.ValidateAll() if the designated
// constraints aren't met.
type GetReceiptAdviceHeaderByPkRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReceiptAdviceHeaderByPkRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReceiptAdviceHeaderByPkRequestMultiError) AllErrors() []error { return m }

// GetReceiptAdviceHeaderByPkRequestValidationError is the validation error
// returned by GetReceiptAdviceHeaderByPkRequest.Validate if the designated
// constraints aren't met.
type GetReceiptAdviceHeaderByPkRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReceiptAdviceHeaderByPkRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReceiptAdviceHeaderByPkRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReceiptAdviceHeaderByPkRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReceiptAdviceHeaderByPkRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReceiptAdviceHeaderByPkRequestValidationError) ErrorName() string {
	return "GetReceiptAdviceHeaderByPkRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetReceiptAdviceHeaderByPkRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReceiptAdviceHeaderByPkRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReceiptAdviceHeaderByPkRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReceiptAdviceHeaderByPkRequestValidationError{}

// Validate checks the field values on GetReceiptAdviceHeaderByPkResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *GetReceiptAdviceHeaderByPkResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReceiptAdviceHeaderByPkResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// GetReceiptAdviceHeaderByPkResponseMultiError, or nil if none found.
func (m *GetReceiptAdviceHeaderByPkResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReceiptAdviceHeaderByPkResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReceiptAdviceHeader()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReceiptAdviceHeaderByPkResponseValidationError{
					field:  "ReceiptAdviceHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReceiptAdviceHeaderByPkResponseValidationError{
					field:  "ReceiptAdviceHeader",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReceiptAdviceHeader()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReceiptAdviceHeaderByPkResponseValidationError{
				field:  "ReceiptAdviceHeader",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetReceiptAdviceHeaderByPkResponseMultiError(errors)
	}

	return nil
}

// GetReceiptAdviceHeaderByPkResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetReceiptAdviceHeaderByPkResponse.ValidateAll() if the designated
// constraints aren't met.
type GetReceiptAdviceHeaderByPkResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReceiptAdviceHeaderByPkResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReceiptAdviceHeaderByPkResponseMultiError) AllErrors() []error { return m }

// GetReceiptAdviceHeaderByPkResponseValidationError is the validation error
// returned by GetReceiptAdviceHeaderByPkResponse.Validate if the designated
// constraints aren't met.
type GetReceiptAdviceHeaderByPkResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReceiptAdviceHeaderByPkResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReceiptAdviceHeaderByPkResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReceiptAdviceHeaderByPkResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReceiptAdviceHeaderByPkResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReceiptAdviceHeaderByPkResponseValidationError) ErrorName() string {
	return "GetReceiptAdviceHeaderByPkResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetReceiptAdviceHeaderByPkResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReceiptAdviceHeaderByPkResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReceiptAdviceHeaderByPkResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReceiptAdviceHeaderByPkResponseValidationError{}

// Validate checks the field values on GetReceiptAdviceHeadersResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReceiptAdviceHeadersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReceiptAdviceHeadersResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetReceiptAdviceHeadersResponseMultiError, or nil if none found.
func (m *GetReceiptAdviceHeadersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReceiptAdviceHeadersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetReceiptAdviceHeaders() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetReceiptAdviceHeadersResponseValidationError{
						field:  fmt.Sprintf("ReceiptAdviceHeaders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetReceiptAdviceHeadersResponseValidationError{
						field:  fmt.Sprintf("ReceiptAdviceHeaders[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetReceiptAdviceHeadersResponseValidationError{
					field:  fmt.Sprintf("ReceiptAdviceHeaders[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for NextCursor

	if len(errors) > 0 {
		return GetReceiptAdviceHeadersResponseMultiError(errors)
	}

	return nil
}

// GetReceiptAdviceHeadersResponseMultiError is an error wrapping multiple
// validation errors returned by GetReceiptAdviceHeadersResponse.ValidateAll()
// if the designated constraints aren't met.
type GetReceiptAdviceHeadersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReceiptAdviceHeadersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReceiptAdviceHeadersResponseMultiError) AllErrors() []error { return m }

// GetReceiptAdviceHeadersResponseValidationError is the validation error
// returned by GetReceiptAdviceHeadersResponse.Validate if the designated
// constraints aren't met.
type GetReceiptAdviceHeadersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReceiptAdviceHeadersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReceiptAdviceHeadersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReceiptAdviceHeadersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReceiptAdviceHeadersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReceiptAdviceHeadersResponseValidationError) ErrorName() string {
	return "GetReceiptAdviceHeadersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetReceiptAdviceHeadersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReceiptAdviceHeadersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReceiptAdviceHeadersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReceiptAdviceHeadersResponseValidationError{}

// Validate checks the field values on GetReceiptAdviceHeadersRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReceiptAdviceHeadersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReceiptAdviceHeadersRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetReceiptAdviceHeadersRequestMultiError, or nil if none found.
func (m *GetReceiptAdviceHeadersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReceiptAdviceHeadersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	// no validation rules for NextCursor

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return GetReceiptAdviceHeadersRequestMultiError(errors)
	}

	return nil
}

// GetReceiptAdviceHeadersRequestMultiError is an error wrapping multiple
// validation errors returned by GetReceiptAdviceHeadersRequest.ValidateAll()
// if the designated constraints aren't met.
type GetReceiptAdviceHeadersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReceiptAdviceHeadersRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReceiptAdviceHeadersRequestMultiError) AllErrors() []error { return m }

// GetReceiptAdviceHeadersRequestValidationError is the validation error
// returned by GetReceiptAdviceHeadersRequest.Validate if the designated
// constraints aren't met.
type GetReceiptAdviceHeadersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReceiptAdviceHeadersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReceiptAdviceHeadersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReceiptAdviceHeadersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReceiptAdviceHeadersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReceiptAdviceHeadersRequestValidationError) ErrorName() string {
	return "GetReceiptAdviceHeadersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetReceiptAdviceHeadersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReceiptAdviceHeadersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReceiptAdviceHeadersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReceiptAdviceHeadersRequestValidationError{}

// Validate checks the field values on ReceiptAdviceLine with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ReceiptAdviceLine) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceiptAdviceLine with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReceiptAdviceLineMultiError, or nil if none found.
func (m *ReceiptAdviceLine) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceiptAdviceLine) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReceiptAdviceLineD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReceiptAdviceLineValidationError{
					field:  "ReceiptAdviceLineD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReceiptAdviceLineValidationError{
					field:  "ReceiptAdviceLineD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReceiptAdviceLineD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReceiptAdviceLineValidationError{
				field:  "ReceiptAdviceLineD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetReceiptAdviceLineT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReceiptAdviceLineValidationError{
					field:  "ReceiptAdviceLineT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReceiptAdviceLineValidationError{
					field:  "ReceiptAdviceLineT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReceiptAdviceLineT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReceiptAdviceLineValidationError{
				field:  "ReceiptAdviceLineT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReceiptAdviceLineValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReceiptAdviceLineValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReceiptAdviceLineValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReceiptAdviceLineValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReceiptAdviceLineValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReceiptAdviceLineValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReceiptAdviceLineMultiError(errors)
	}

	return nil
}

// ReceiptAdviceLineMultiError is an error wrapping multiple validation errors
// returned by ReceiptAdviceLine.ValidateAll() if the designated constraints
// aren't met.
type ReceiptAdviceLineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceiptAdviceLineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceiptAdviceLineMultiError) AllErrors() []error { return m }

// ReceiptAdviceLineValidationError is the validation error returned by
// ReceiptAdviceLine.Validate if the designated constraints aren't met.
type ReceiptAdviceLineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceiptAdviceLineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceiptAdviceLineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceiptAdviceLineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceiptAdviceLineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceiptAdviceLineValidationError) ErrorName() string {
	return "ReceiptAdviceLineValidationError"
}

// Error satisfies the builtin error interface
func (e ReceiptAdviceLineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceiptAdviceLine.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceiptAdviceLineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceiptAdviceLineValidationError{}

// Validate checks the field values on ReceiptAdviceLineD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReceiptAdviceLineD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceiptAdviceLineD with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReceiptAdviceLineDMultiError, or nil if none found.
func (m *ReceiptAdviceLineD) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceiptAdviceLineD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for RcptlId

	// no validation rules for Note

	// no validation rules for ReceivedQuantity

	// no validation rules for ShortQuantity

	// no validation rules for ShortageActionCode

	// no validation rules for RejectedQuantity

	// no validation rules for RejectReasonCode

	// no validation rules for RejectReason

	// no validation rules for RejectActionCode

	// no validation rules for QuantityDiscrepancyCode

	// no validation rules for OversupplyQuantity

	// no validation rules for TimingComplaintCode

	// no validation rules for TimingComplaint

	// no validation rules for OrderLineId

	// no validation rules for DespatchLineId

	// no validation rules for ItemId

	// no validation rules for ShipmentId

	// no validation rules for ReceiptAdviceHeaderId

	if len(errors) > 0 {
		return ReceiptAdviceLineDMultiError(errors)
	}

	return nil
}

// ReceiptAdviceLineDMultiError is an error wrapping multiple validation errors
// returned by ReceiptAdviceLineD.ValidateAll() if the designated constraints
// aren't met.
type ReceiptAdviceLineDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceiptAdviceLineDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceiptAdviceLineDMultiError) AllErrors() []error { return m }

// ReceiptAdviceLineDValidationError is the validation error returned by
// ReceiptAdviceLineD.Validate if the designated constraints aren't met.
type ReceiptAdviceLineDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceiptAdviceLineDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceiptAdviceLineDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceiptAdviceLineDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceiptAdviceLineDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceiptAdviceLineDValidationError) ErrorName() string {
	return "ReceiptAdviceLineDValidationError"
}

// Error satisfies the builtin error interface
func (e ReceiptAdviceLineDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceiptAdviceLineD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceiptAdviceLineDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceiptAdviceLineDValidationError{}

// Validate checks the field values on ReceiptAdviceLineT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ReceiptAdviceLineT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ReceiptAdviceLineT with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ReceiptAdviceLineTMultiError, or nil if none found.
func (m *ReceiptAdviceLineT) ValidateAll() error {
	return m.validate(true)
}

func (m *ReceiptAdviceLineT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReceivedDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ReceiptAdviceLineTValidationError{
					field:  "ReceivedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ReceiptAdviceLineTValidationError{
					field:  "ReceivedDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReceivedDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ReceiptAdviceLineTValidationError{
				field:  "ReceivedDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ReceiptAdviceLineTMultiError(errors)
	}

	return nil
}

// ReceiptAdviceLineTMultiError is an error wrapping multiple validation errors
// returned by ReceiptAdviceLineT.ValidateAll() if the designated constraints
// aren't met.
type ReceiptAdviceLineTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReceiptAdviceLineTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReceiptAdviceLineTMultiError) AllErrors() []error { return m }

// ReceiptAdviceLineTValidationError is the validation error returned by
// ReceiptAdviceLineT.Validate if the designated constraints aren't met.
type ReceiptAdviceLineTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReceiptAdviceLineTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReceiptAdviceLineTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReceiptAdviceLineTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReceiptAdviceLineTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReceiptAdviceLineTValidationError) ErrorName() string {
	return "ReceiptAdviceLineTValidationError"
}

// Error satisfies the builtin error interface
func (e ReceiptAdviceLineTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReceiptAdviceLineT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReceiptAdviceLineTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReceiptAdviceLineTValidationError{}

// Validate checks the field values on CreateReceiptAdviceLineRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateReceiptAdviceLineRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateReceiptAdviceLineRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateReceiptAdviceLineRequestMultiError, or nil if none found.
func (m *CreateReceiptAdviceLineRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReceiptAdviceLineRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RcptlId

	// no validation rules for Note

	// no validation rules for ReceivedQuantity

	// no validation rules for ShortQuantity

	// no validation rules for ShortageActionCode

	// no validation rules for RejectedQuantity

	// no validation rules for RejectReasonCode

	// no validation rules for RejectReason

	// no validation rules for RejectActionCode

	// no validation rules for QuantityDiscrepancyCode

	// no validation rules for OversupplyQuantity

	// no validation rules for ReceivedDate

	// no validation rules for TimingComplaintCode

	// no validation rules for TimingComplaint

	// no validation rules for OrderLineId

	// no validation rules for DespatchLineId

	// no validation rules for ItemId

	// no validation rules for ShipmentId

	// no validation rules for ReceiptAdviceHeaderId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateReceiptAdviceLineRequestMultiError(errors)
	}

	return nil
}

// CreateReceiptAdviceLineRequestMultiError is an error wrapping multiple
// validation errors returned by CreateReceiptAdviceLineRequest.ValidateAll()
// if the designated constraints aren't met.
type CreateReceiptAdviceLineRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReceiptAdviceLineRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReceiptAdviceLineRequestMultiError) AllErrors() []error { return m }

// CreateReceiptAdviceLineRequestValidationError is the validation error
// returned by CreateReceiptAdviceLineRequest.Validate if the designated
// constraints aren't met.
type CreateReceiptAdviceLineRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReceiptAdviceLineRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReceiptAdviceLineRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateReceiptAdviceLineRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReceiptAdviceLineRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReceiptAdviceLineRequestValidationError) ErrorName() string {
	return "CreateReceiptAdviceLineRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateReceiptAdviceLineRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReceiptAdviceLineRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReceiptAdviceLineRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReceiptAdviceLineRequestValidationError{}

// Validate checks the field values on CreateReceiptAdviceLineResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateReceiptAdviceLineResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateReceiptAdviceLineResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateReceiptAdviceLineResponseMultiError, or nil if none found.
func (m *CreateReceiptAdviceLineResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateReceiptAdviceLineResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetReceiptAdviceLine()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateReceiptAdviceLineResponseValidationError{
					field:  "ReceiptAdviceLine",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateReceiptAdviceLineResponseValidationError{
					field:  "ReceiptAdviceLine",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReceiptAdviceLine()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateReceiptAdviceLineResponseValidationError{
				field:  "ReceiptAdviceLine",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateReceiptAdviceLineResponseMultiError(errors)
	}

	return nil
}

// CreateReceiptAdviceLineResponseMultiError is an error wrapping multiple
// validation errors returned by CreateReceiptAdviceLineResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateReceiptAdviceLineResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateReceiptAdviceLineResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateReceiptAdviceLineResponseMultiError) AllErrors() []error { return m }

// CreateReceiptAdviceLineResponseValidationError is the validation error
// returned by CreateReceiptAdviceLineResponse.Validate if the designated
// constraints aren't met.
type CreateReceiptAdviceLineResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateReceiptAdviceLineResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateReceiptAdviceLineResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateReceiptAdviceLineResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateReceiptAdviceLineResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateReceiptAdviceLineResponseValidationError) ErrorName() string {
	return "CreateReceiptAdviceLineResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateReceiptAdviceLineResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateReceiptAdviceLineResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateReceiptAdviceLineResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateReceiptAdviceLineResponseValidationError{}

// Validate checks the field values on GetReceiptAdviceLinesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReceiptAdviceLinesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReceiptAdviceLinesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetReceiptAdviceLinesRequestMultiError, or nil if none found.
func (m *GetReceiptAdviceLinesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReceiptAdviceLinesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetGetRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetReceiptAdviceLinesRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetReceiptAdviceLinesRequestValidationError{
					field:  "GetRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGetRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetReceiptAdviceLinesRequestValidationError{
				field:  "GetRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetReceiptAdviceLinesRequestMultiError(errors)
	}

	return nil
}

// GetReceiptAdviceLinesRequestMultiError is an error wrapping multiple
// validation errors returned by GetReceiptAdviceLinesRequest.ValidateAll() if
// the designated constraints aren't met.
type GetReceiptAdviceLinesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReceiptAdviceLinesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReceiptAdviceLinesRequestMultiError) AllErrors() []error { return m }

// GetReceiptAdviceLinesRequestValidationError is the validation error returned
// by GetReceiptAdviceLinesRequest.Validate if the designated constraints
// aren't met.
type GetReceiptAdviceLinesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReceiptAdviceLinesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReceiptAdviceLinesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReceiptAdviceLinesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReceiptAdviceLinesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReceiptAdviceLinesRequestValidationError) ErrorName() string {
	return "GetReceiptAdviceLinesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetReceiptAdviceLinesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReceiptAdviceLinesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReceiptAdviceLinesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReceiptAdviceLinesRequestValidationError{}

// Validate checks the field values on GetReceiptAdviceLinesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetReceiptAdviceLinesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetReceiptAdviceLinesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// GetReceiptAdviceLinesResponseMultiError, or nil if none found.
func (m *GetReceiptAdviceLinesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetReceiptAdviceLinesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetReceiptAdviceLines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetReceiptAdviceLinesResponseValidationError{
						field:  fmt.Sprintf("ReceiptAdviceLines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetReceiptAdviceLinesResponseValidationError{
						field:  fmt.Sprintf("ReceiptAdviceLines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetReceiptAdviceLinesResponseValidationError{
					field:  fmt.Sprintf("ReceiptAdviceLines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetReceiptAdviceLinesResponseMultiError(errors)
	}

	return nil
}

// GetReceiptAdviceLinesResponseMultiError is an error wrapping multiple
// validation errors returned by GetReceiptAdviceLinesResponse.ValidateAll()
// if the designated constraints aren't met.
type GetReceiptAdviceLinesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetReceiptAdviceLinesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetReceiptAdviceLinesResponseMultiError) AllErrors() []error { return m }

// GetReceiptAdviceLinesResponseValidationError is the validation error
// returned by GetReceiptAdviceLinesResponse.Validate if the designated
// constraints aren't met.
type GetReceiptAdviceLinesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetReceiptAdviceLinesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetReceiptAdviceLinesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetReceiptAdviceLinesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetReceiptAdviceLinesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetReceiptAdviceLinesResponseValidationError) ErrorName() string {
	return "GetReceiptAdviceLinesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetReceiptAdviceLinesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetReceiptAdviceLinesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetReceiptAdviceLinesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetReceiptAdviceLinesResponseValidationError{}

// Validate checks the field values on UpdateReceiptAdviceHeaderRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateReceiptAdviceHeaderRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateReceiptAdviceHeaderRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// UpdateReceiptAdviceHeaderRequestMultiError, or nil if none found.
func (m *UpdateReceiptAdviceHeaderRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateReceiptAdviceHeaderRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReceiptAdviceTypeCode

	// no validation rules for Note

	// no validation rules for LineCountNumeric

	// no validation rules for Id

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return UpdateReceiptAdviceHeaderRequestMultiError(errors)
	}

	return nil
}

// UpdateReceiptAdviceHeaderRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateReceiptAdviceHeaderRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateReceiptAdviceHeaderRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateReceiptAdviceHeaderRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateReceiptAdviceHeaderRequestMultiError) AllErrors() []error { return m }

// UpdateReceiptAdviceHeaderRequestValidationError is the validation error
// returned by UpdateReceiptAdviceHeaderRequest.Validate if the designated
// constraints aren't met.
type UpdateReceiptAdviceHeaderRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateReceiptAdviceHeaderRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateReceiptAdviceHeaderRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateReceiptAdviceHeaderRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateReceiptAdviceHeaderRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateReceiptAdviceHeaderRequestValidationError) ErrorName() string {
	return "UpdateReceiptAdviceHeaderRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateReceiptAdviceHeaderRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateReceiptAdviceHeaderRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateReceiptAdviceHeaderRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateReceiptAdviceHeaderRequestValidationError{}

// Validate checks the field values on UpdateReceiptAdviceHeaderResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *UpdateReceiptAdviceHeaderResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateReceiptAdviceHeaderResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// UpdateReceiptAdviceHeaderResponseMultiError, or nil if none found.
func (m *UpdateReceiptAdviceHeaderResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateReceiptAdviceHeaderResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateReceiptAdviceHeaderResponseMultiError(errors)
	}

	return nil
}

// UpdateReceiptAdviceHeaderResponseMultiError is an error wrapping multiple
// validation errors returned by
// UpdateReceiptAdviceHeaderResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdateReceiptAdviceHeaderResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateReceiptAdviceHeaderResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateReceiptAdviceHeaderResponseMultiError) AllErrors() []error { return m }

// UpdateReceiptAdviceHeaderResponseValidationError is the validation error
// returned by UpdateReceiptAdviceHeaderResponse.Validate if the designated
// constraints aren't met.
type UpdateReceiptAdviceHeaderResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateReceiptAdviceHeaderResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateReceiptAdviceHeaderResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateReceiptAdviceHeaderResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateReceiptAdviceHeaderResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateReceiptAdviceHeaderResponseValidationError) ErrorName() string {
	return "UpdateReceiptAdviceHeaderResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateReceiptAdviceHeaderResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateReceiptAdviceHeaderResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateReceiptAdviceHeaderResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateReceiptAdviceHeaderResponseValidationError{}
