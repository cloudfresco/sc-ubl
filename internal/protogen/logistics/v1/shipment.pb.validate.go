// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: logistics/v1/shipment.proto

package v1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Delivery with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Delivery) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Delivery with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeliveryMultiError, or nil
// if none found.
func (m *Delivery) ValidateAll() error {
	return m.validate(true)
}

func (m *Delivery) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDeliveryD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryValidationError{
					field:  "DeliveryD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryValidationError{
					field:  "DeliveryD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryValidationError{
				field:  "DeliveryD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeliveryT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryValidationError{
					field:  "DeliveryT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryValidationError{
					field:  "DeliveryT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryValidationError{
				field:  "DeliveryT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetDeliveryTerm() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeliveryValidationError{
						field:  fmt.Sprintf("DeliveryTerm[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeliveryValidationError{
						field:  fmt.Sprintf("DeliveryTerm[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeliveryValidationError{
					field:  fmt.Sprintf("DeliveryTerm[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetDespatch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryValidationError{
					field:  "Despatch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryValidationError{
					field:  "Despatch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDespatch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryValidationError{
				field:  "Despatch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeliveryMultiError(errors)
	}

	return nil
}

// DeliveryMultiError is an error wrapping multiple validation errors returned
// by Delivery.ValidateAll() if the designated constraints aren't met.
type DeliveryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryMultiError) AllErrors() []error { return m }

// DeliveryValidationError is the validation error returned by
// Delivery.Validate if the designated constraints aren't met.
type DeliveryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryValidationError) ErrorName() string { return "DeliveryValidationError" }

// Error satisfies the builtin error interface
func (e DeliveryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDelivery.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryValidationError{}

// Validate checks the field values on DeliveryD with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeliveryD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryD with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeliveryDMultiError, or nil
// if none found.
func (m *DeliveryD) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for DelId

	// no validation rules for Quantity

	// no validation rules for MinimumQuantity

	// no validation rules for MaximumQuantity

	// no validation rules for ReleaseId

	// no validation rules for TrackingId

	// no validation rules for MinimumBatchQuantity

	// no validation rules for MaximumBatchQuantity

	// no validation rules for ConsumerUnitQuantity

	// no validation rules for HazardousRiskIndicator

	// no validation rules for DeliveryAddressId

	// no validation rules for DeliveryLocationId

	// no validation rules for AlternativeDeliveryLocationId

	// no validation rules for CarrierPartyId

	// no validation rules for DeliveryPartyId

	// no validation rules for NotifyPartyId

	// no validation rules for DespatchId

	// no validation rules for ShipmentId

	if len(errors) > 0 {
		return DeliveryDMultiError(errors)
	}

	return nil
}

// DeliveryDMultiError is an error wrapping multiple validation errors returned
// by DeliveryD.ValidateAll() if the designated constraints aren't met.
type DeliveryDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryDMultiError) AllErrors() []error { return m }

// DeliveryDValidationError is the validation error returned by
// DeliveryD.Validate if the designated constraints aren't met.
type DeliveryDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryDValidationError) ErrorName() string { return "DeliveryDValidationError" }

// Error satisfies the builtin error interface
func (e DeliveryDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryDValidationError{}

// Validate checks the field values on DeliveryT with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeliveryT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryT with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeliveryTMultiError, or nil
// if none found.
func (m *DeliveryT) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetActualDeliveryDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "ActualDeliveryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "ActualDeliveryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActualDeliveryDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryTValidationError{
				field:  "ActualDeliveryDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLatestDeliveryDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "LatestDeliveryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "LatestDeliveryDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLatestDeliveryDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryTValidationError{
				field:  "LatestDeliveryDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRequestedDeliveryPeriodStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "RequestedDeliveryPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "RequestedDeliveryPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestedDeliveryPeriodStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryTValidationError{
				field:  "RequestedDeliveryPeriodStartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRequestedDeliveryPeriodEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "RequestedDeliveryPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "RequestedDeliveryPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestedDeliveryPeriodEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryTValidationError{
				field:  "RequestedDeliveryPeriodEndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPromisedDeliveryPeriodStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "PromisedDeliveryPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "PromisedDeliveryPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPromisedDeliveryPeriodStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryTValidationError{
				field:  "PromisedDeliveryPeriodStartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPromisedDeliveryPeriodEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "PromisedDeliveryPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "PromisedDeliveryPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPromisedDeliveryPeriodEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryTValidationError{
				field:  "PromisedDeliveryPeriodEndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEstimatedDeliveryPeriodStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "EstimatedDeliveryPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "EstimatedDeliveryPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEstimatedDeliveryPeriodStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryTValidationError{
				field:  "EstimatedDeliveryPeriodStartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEstimatedDeliveryPeriodEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "EstimatedDeliveryPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryTValidationError{
					field:  "EstimatedDeliveryPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEstimatedDeliveryPeriodEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryTValidationError{
				field:  "EstimatedDeliveryPeriodEndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeliveryTMultiError(errors)
	}

	return nil
}

// DeliveryTMultiError is an error wrapping multiple validation errors returned
// by DeliveryT.ValidateAll() if the designated constraints aren't met.
type DeliveryTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryTMultiError) AllErrors() []error { return m }

// DeliveryTValidationError is the validation error returned by
// DeliveryT.Validate if the designated constraints aren't met.
type DeliveryTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryTValidationError) ErrorName() string { return "DeliveryTValidationError" }

// Error satisfies the builtin error interface
func (e DeliveryTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryTValidationError{}

// Validate checks the field values on CreateDeliveryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDeliveryRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDeliveryRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDeliveryRequestMultiError, or nil if none found.
func (m *CreateDeliveryRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDeliveryRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DelId

	// no validation rules for Quantity

	// no validation rules for MinimumQuantity

	// no validation rules for MaximumQuantity

	// no validation rules for ActualDeliveryDate

	// no validation rules for LatestDeliveryDate

	// no validation rules for ReleaseId

	// no validation rules for TrackingId

	// no validation rules for RequestedDeliveryPeriodStartDate

	// no validation rules for RequestedDeliveryPeriodEndDate

	// no validation rules for PromisedDeliveryPeriodStartDate

	// no validation rules for PromisedDeliveryPeriodEndDate

	// no validation rules for EstimatedDeliveryPeriodStartDate

	// no validation rules for EstimatedDeliveryPeriodEndDate

	// no validation rules for MinimumBatchQuantity

	// no validation rules for MaximumBatchQuantity

	// no validation rules for ConsumerUnitQuantity

	// no validation rules for HazardousRiskIndicator

	// no validation rules for DeliveryAddressId

	// no validation rules for DeliveryLocationId

	// no validation rules for AlternativeDeliveryLocationId

	// no validation rules for CarrierPartyId

	// no validation rules for DeliveryPartyId

	// no validation rules for NotifyPartyId

	// no validation rules for DespatchId

	// no validation rules for ShipmentId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if all {
		switch v := interface{}(m.GetDeliveryAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDeliveryRequestValidationError{
					field:  "DeliveryAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDeliveryRequestValidationError{
					field:  "DeliveryAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDeliveryRequestValidationError{
				field:  "DeliveryAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDeliveryLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDeliveryRequestValidationError{
					field:  "DeliveryLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDeliveryRequestValidationError{
					field:  "DeliveryLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDeliveryRequestValidationError{
				field:  "DeliveryLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAlternativeDeliveryLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDeliveryRequestValidationError{
					field:  "AlternativeDeliveryLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDeliveryRequestValidationError{
					field:  "AlternativeDeliveryLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlternativeDeliveryLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDeliveryRequestValidationError{
				field:  "AlternativeDeliveryLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateDeliveryRequestMultiError(errors)
	}

	return nil
}

// CreateDeliveryRequestMultiError is an error wrapping multiple validation
// errors returned by CreateDeliveryRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateDeliveryRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDeliveryRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDeliveryRequestMultiError) AllErrors() []error { return m }

// CreateDeliveryRequestValidationError is the validation error returned by
// CreateDeliveryRequest.Validate if the designated constraints aren't met.
type CreateDeliveryRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDeliveryRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDeliveryRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDeliveryRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDeliveryRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDeliveryRequestValidationError) ErrorName() string {
	return "CreateDeliveryRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDeliveryRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDeliveryRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDeliveryRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDeliveryRequestValidationError{}

// Validate checks the field values on CreateDeliveryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDeliveryResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDeliveryResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDeliveryResponseMultiError, or nil if none found.
func (m *CreateDeliveryResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDeliveryResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDelivery()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDeliveryResponseValidationError{
					field:  "Delivery",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDeliveryResponseValidationError{
					field:  "Delivery",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDelivery()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDeliveryResponseValidationError{
				field:  "Delivery",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateDeliveryResponseMultiError(errors)
	}

	return nil
}

// CreateDeliveryResponseMultiError is an error wrapping multiple validation
// errors returned by CreateDeliveryResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateDeliveryResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDeliveryResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDeliveryResponseMultiError) AllErrors() []error { return m }

// CreateDeliveryResponseValidationError is the validation error returned by
// CreateDeliveryResponse.Validate if the designated constraints aren't met.
type CreateDeliveryResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDeliveryResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDeliveryResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDeliveryResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDeliveryResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDeliveryResponseValidationError) ErrorName() string {
	return "CreateDeliveryResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDeliveryResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDeliveryResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDeliveryResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDeliveryResponseValidationError{}

// Validate checks the field values on DeliveryTerm with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeliveryTerm) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryTerm with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeliveryTermMultiError, or
// nil if none found.
func (m *DeliveryTerm) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryTerm) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDeliveryTermD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryTermValidationError{
					field:  "DeliveryTermD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryTermValidationError{
					field:  "DeliveryTermD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryTermD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryTermValidationError{
				field:  "DeliveryTermD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryTermValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryTermValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryTermValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeliveryTermValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeliveryTermValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeliveryTermValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeliveryTermMultiError(errors)
	}

	return nil
}

// DeliveryTermMultiError is an error wrapping multiple validation errors
// returned by DeliveryTerm.ValidateAll() if the designated constraints aren't met.
type DeliveryTermMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryTermMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryTermMultiError) AllErrors() []error { return m }

// DeliveryTermValidationError is the validation error returned by
// DeliveryTerm.Validate if the designated constraints aren't met.
type DeliveryTermValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryTermValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryTermValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryTermValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryTermValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryTermValidationError) ErrorName() string { return "DeliveryTermValidationError" }

// Error satisfies the builtin error interface
func (e DeliveryTermValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryTerm.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryTermValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryTermValidationError{}

// Validate checks the field values on DeliveryTermD with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeliveryTermD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeliveryTermD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeliveryTermDMultiError, or
// nil if none found.
func (m *DeliveryTermD) ValidateAll() error {
	return m.validate(true)
}

func (m *DeliveryTermD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for DelTermId

	// no validation rules for SpecialTerms

	// no validation rules for LossRiskResponsibilityCode

	// no validation rules for LossRisk

	// no validation rules for Amount

	// no validation rules for DeliveryLocationId

	// no validation rules for DelTermAllowanceChargeId

	// no validation rules for DeliveryId

	if len(errors) > 0 {
		return DeliveryTermDMultiError(errors)
	}

	return nil
}

// DeliveryTermDMultiError is an error wrapping multiple validation errors
// returned by DeliveryTermD.ValidateAll() if the designated constraints
// aren't met.
type DeliveryTermDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeliveryTermDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeliveryTermDMultiError) AllErrors() []error { return m }

// DeliveryTermDValidationError is the validation error returned by
// DeliveryTermD.Validate if the designated constraints aren't met.
type DeliveryTermDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeliveryTermDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeliveryTermDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeliveryTermDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeliveryTermDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeliveryTermDValidationError) ErrorName() string { return "DeliveryTermDValidationError" }

// Error satisfies the builtin error interface
func (e DeliveryTermDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeliveryTermD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeliveryTermDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeliveryTermDValidationError{}

// Validate checks the field values on CreateDeliveryTermRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDeliveryTermRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDeliveryTermRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDeliveryTermRequestMultiError, or nil if none found.
func (m *CreateDeliveryTermRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDeliveryTermRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DelTermId

	// no validation rules for SpecialTerms

	// no validation rules for LossRiskResponsibilityCode

	// no validation rules for LossRisk

	// no validation rules for Amount

	// no validation rules for DeliveryLocationId

	// no validation rules for DelTermAllowanceChargeId

	// no validation rules for DeliveryId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if all {
		switch v := interface{}(m.GetDeliveryLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDeliveryTermRequestValidationError{
					field:  "DeliveryLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDeliveryTermRequestValidationError{
					field:  "DeliveryLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDeliveryTermRequestValidationError{
				field:  "DeliveryLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateDeliveryTermRequestMultiError(errors)
	}

	return nil
}

// CreateDeliveryTermRequestMultiError is an error wrapping multiple validation
// errors returned by CreateDeliveryTermRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateDeliveryTermRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDeliveryTermRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDeliveryTermRequestMultiError) AllErrors() []error { return m }

// CreateDeliveryTermRequestValidationError is the validation error returned by
// CreateDeliveryTermRequest.Validate if the designated constraints aren't met.
type CreateDeliveryTermRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDeliveryTermRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDeliveryTermRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDeliveryTermRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDeliveryTermRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDeliveryTermRequestValidationError) ErrorName() string {
	return "CreateDeliveryTermRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDeliveryTermRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDeliveryTermRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDeliveryTermRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDeliveryTermRequestValidationError{}

// Validate checks the field values on CreateDeliveryTermResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDeliveryTermResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDeliveryTermResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDeliveryTermResponseMultiError, or nil if none found.
func (m *CreateDeliveryTermResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDeliveryTermResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDeliveryTerm()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDeliveryTermResponseValidationError{
					field:  "DeliveryTerm",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDeliveryTermResponseValidationError{
					field:  "DeliveryTerm",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDeliveryTerm()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDeliveryTermResponseValidationError{
				field:  "DeliveryTerm",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateDeliveryTermResponseMultiError(errors)
	}

	return nil
}

// CreateDeliveryTermResponseMultiError is an error wrapping multiple
// validation errors returned by CreateDeliveryTermResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateDeliveryTermResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDeliveryTermResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDeliveryTermResponseMultiError) AllErrors() []error { return m }

// CreateDeliveryTermResponseValidationError is the validation error returned
// by CreateDeliveryTermResponse.Validate if the designated constraints aren't met.
type CreateDeliveryTermResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDeliveryTermResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDeliveryTermResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDeliveryTermResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDeliveryTermResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDeliveryTermResponseValidationError) ErrorName() string {
	return "CreateDeliveryTermResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDeliveryTermResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDeliveryTermResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDeliveryTermResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDeliveryTermResponseValidationError{}

// Validate checks the field values on Despatch with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Despatch) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Despatch with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DespatchMultiError, or nil
// if none found.
func (m *Despatch) ValidateAll() error {
	return m.validate(true)
}

func (m *Despatch) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDespatchD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DespatchValidationError{
					field:  "DespatchD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DespatchValidationError{
					field:  "DespatchD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDespatchD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DespatchValidationError{
				field:  "DespatchD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDespatchT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DespatchValidationError{
					field:  "DespatchT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DespatchValidationError{
					field:  "DespatchT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDespatchT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DespatchValidationError{
				field:  "DespatchT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DespatchMultiError(errors)
	}

	return nil
}

// DespatchMultiError is an error wrapping multiple validation errors returned
// by Despatch.ValidateAll() if the designated constraints aren't met.
type DespatchMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DespatchMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DespatchMultiError) AllErrors() []error { return m }

// DespatchValidationError is the validation error returned by
// Despatch.Validate if the designated constraints aren't met.
type DespatchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DespatchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DespatchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DespatchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DespatchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DespatchValidationError) ErrorName() string { return "DespatchValidationError" }

// Error satisfies the builtin error interface
func (e DespatchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDespatch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DespatchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DespatchValidationError{}

// Validate checks the field values on DespatchD with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DespatchD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DespatchD with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DespatchDMultiError, or nil
// if none found.
func (m *DespatchD) ValidateAll() error {
	return m.validate(true)
}

func (m *DespatchD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for DespId

	// no validation rules for ReleaseId

	// no validation rules for Instructions

	// no validation rules for DespatchAddressId

	// no validation rules for DespatchLocationId

	// no validation rules for DespatchPartyContact

	// no validation rules for DespatchPartyId

	// no validation rules for CarrierPartyId

	// no validation rules for NotifyPartyId

	if len(errors) > 0 {
		return DespatchDMultiError(errors)
	}

	return nil
}

// DespatchDMultiError is an error wrapping multiple validation errors returned
// by DespatchD.ValidateAll() if the designated constraints aren't met.
type DespatchDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DespatchDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DespatchDMultiError) AllErrors() []error { return m }

// DespatchDValidationError is the validation error returned by
// DespatchD.Validate if the designated constraints aren't met.
type DespatchDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DespatchDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DespatchDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DespatchDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DespatchDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DespatchDValidationError) ErrorName() string { return "DespatchDValidationError" }

// Error satisfies the builtin error interface
func (e DespatchDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDespatchD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DespatchDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DespatchDValidationError{}

// Validate checks the field values on DespatchT with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DespatchT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DespatchT with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DespatchTMultiError, or nil
// if none found.
func (m *DespatchT) ValidateAll() error {
	return m.validate(true)
}

func (m *DespatchT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRequestedDespatchDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "RequestedDespatchDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "RequestedDespatchDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestedDespatchDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DespatchTValidationError{
				field:  "RequestedDespatchDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEstimatedDespatchDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "EstimatedDespatchDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "EstimatedDespatchDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEstimatedDespatchDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DespatchTValidationError{
				field:  "EstimatedDespatchDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetActualDespatchDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "ActualDespatchDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "ActualDespatchDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActualDespatchDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DespatchTValidationError{
				field:  "ActualDespatchDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetGuaranteedDespatchDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "GuaranteedDespatchDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "GuaranteedDespatchDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGuaranteedDespatchDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DespatchTValidationError{
				field:  "GuaranteedDespatchDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEstimatedDespatchPeriodStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "EstimatedDespatchPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "EstimatedDespatchPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEstimatedDespatchPeriodStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DespatchTValidationError{
				field:  "EstimatedDespatchPeriodStartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEstimatedDespatchPeriodEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "EstimatedDespatchPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "EstimatedDespatchPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEstimatedDespatchPeriodEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DespatchTValidationError{
				field:  "EstimatedDespatchPeriodEndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRequestedDespatchPeriodStartDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "RequestedDespatchPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "RequestedDespatchPeriodStartDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestedDespatchPeriodStartDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DespatchTValidationError{
				field:  "RequestedDespatchPeriodStartDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRequestedDespatchPeriodEndDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "RequestedDespatchPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DespatchTValidationError{
					field:  "RequestedDespatchPeriodEndDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRequestedDespatchPeriodEndDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DespatchTValidationError{
				field:  "RequestedDespatchPeriodEndDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DespatchTMultiError(errors)
	}

	return nil
}

// DespatchTMultiError is an error wrapping multiple validation errors returned
// by DespatchT.ValidateAll() if the designated constraints aren't met.
type DespatchTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DespatchTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DespatchTMultiError) AllErrors() []error { return m }

// DespatchTValidationError is the validation error returned by
// DespatchT.Validate if the designated constraints aren't met.
type DespatchTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DespatchTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DespatchTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DespatchTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DespatchTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DespatchTValidationError) ErrorName() string { return "DespatchTValidationError" }

// Error satisfies the builtin error interface
func (e DespatchTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDespatchT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DespatchTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DespatchTValidationError{}

// Validate checks the field values on CreateDespatchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDespatchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDespatchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDespatchRequestMultiError, or nil if none found.
func (m *CreateDespatchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDespatchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DespId

	// no validation rules for RequestedDespatchDate

	// no validation rules for EstimatedDespatchDate

	// no validation rules for ActualDespatchDate

	// no validation rules for GuaranteedDespatchDate

	// no validation rules for ReleaseId

	// no validation rules for Instructions

	// no validation rules for EstimatedDespatchPeriodStartDate

	// no validation rules for EstimatedDespatchPeriodEndDate

	// no validation rules for RequestedDespatchPeriodStartDate

	// no validation rules for RequestedDespatchPeriodEndDate

	// no validation rules for DespatchAddressId

	// no validation rules for DespatchLocationId

	// no validation rules for DespatchPartyContact

	// no validation rules for DespatchPartyId

	// no validation rules for CarrierPartyId

	// no validation rules for NotifyPartyId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if all {
		switch v := interface{}(m.GetDespatchAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDespatchRequestValidationError{
					field:  "DespatchAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDespatchRequestValidationError{
					field:  "DespatchAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDespatchAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDespatchRequestValidationError{
				field:  "DespatchAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDespatchLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDespatchRequestValidationError{
					field:  "DespatchLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDespatchRequestValidationError{
					field:  "DespatchLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDespatchLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDespatchRequestValidationError{
				field:  "DespatchLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateDespatchRequestMultiError(errors)
	}

	return nil
}

// CreateDespatchRequestMultiError is an error wrapping multiple validation
// errors returned by CreateDespatchRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateDespatchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDespatchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDespatchRequestMultiError) AllErrors() []error { return m }

// CreateDespatchRequestValidationError is the validation error returned by
// CreateDespatchRequest.Validate if the designated constraints aren't met.
type CreateDespatchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDespatchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDespatchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDespatchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDespatchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDespatchRequestValidationError) ErrorName() string {
	return "CreateDespatchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDespatchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDespatchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDespatchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDespatchRequestValidationError{}

// Validate checks the field values on CreateDespatchResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDespatchResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDespatchResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDespatchResponseMultiError, or nil if none found.
func (m *CreateDespatchResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDespatchResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDespatch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDespatchResponseValidationError{
					field:  "Despatch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDespatchResponseValidationError{
					field:  "Despatch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDespatch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDespatchResponseValidationError{
				field:  "Despatch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateDespatchResponseMultiError(errors)
	}

	return nil
}

// CreateDespatchResponseMultiError is an error wrapping multiple validation
// errors returned by CreateDespatchResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateDespatchResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDespatchResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDespatchResponseMultiError) AllErrors() []error { return m }

// CreateDespatchResponseValidationError is the validation error returned by
// CreateDespatchResponse.Validate if the designated constraints aren't met.
type CreateDespatchResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDespatchResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDespatchResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDespatchResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDespatchResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDespatchResponseValidationError) ErrorName() string {
	return "CreateDespatchResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDespatchResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDespatchResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDespatchResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDespatchResponseValidationError{}

// Validate checks the field values on Shipment with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Shipment) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Shipment with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ShipmentMultiError, or nil
// if none found.
func (m *Shipment) ValidateAll() error {
	return m.validate(true)
}

func (m *Shipment) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetShipmentD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShipmentValidationError{
					field:  "ShipmentD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShipmentValidationError{
					field:  "ShipmentD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetShipmentD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShipmentValidationError{
				field:  "ShipmentD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShipmentValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShipmentValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShipmentValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ShipmentValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ShipmentValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ShipmentValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ShipmentMultiError(errors)
	}

	return nil
}

// ShipmentMultiError is an error wrapping multiple validation errors returned
// by Shipment.ValidateAll() if the designated constraints aren't met.
type ShipmentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShipmentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShipmentMultiError) AllErrors() []error { return m }

// ShipmentValidationError is the validation error returned by
// Shipment.Validate if the designated constraints aren't met.
type ShipmentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShipmentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShipmentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShipmentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShipmentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShipmentValidationError) ErrorName() string { return "ShipmentValidationError" }

// Error satisfies the builtin error interface
func (e ShipmentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShipment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShipmentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShipmentValidationError{}

// Validate checks the field values on ShipmentD with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ShipmentD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ShipmentD with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ShipmentDMultiError, or nil
// if none found.
func (m *ShipmentD) ValidateAll() error {
	return m.validate(true)
}

func (m *ShipmentD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for ShId

	// no validation rules for ShippingPriorityLevelCode

	// no validation rules for HandlingCode

	// no validation rules for HandlingInstructions

	// no validation rules for Information

	// no validation rules for GrossWeightMeasure

	// no validation rules for NetWeightMeasure

	// no validation rules for NetNetWeightMeasure

	// no validation rules for GrossVolumeMeasure

	// no validation rules for NetVolumeMeasure

	// no validation rules for TotalGoodsItemQuantity

	// no validation rules for TotalTransportHandlingUnitQuantity

	// no validation rules for InsuranceValueAmount

	// no validation rules for DeclaredCustomsValueAmount

	// no validation rules for DeclaredForCarriageValueAmount

	// no validation rules for DeclaredStatisticsValueAmount

	// no validation rules for FreeOnBoardValueAmount

	// no validation rules for SpecialInstructions

	// no validation rules for DeliveryInstructions

	// no validation rules for SplitConsignmentIndicator

	// no validation rules for ConsignmentQuantity

	// no validation rules for ReturnAddressId

	// no validation rules for OriginAddressId

	// no validation rules for FirstArrivalPortLocationId

	// no validation rules for LastExitPortLocationId

	// no validation rules for ExportCountryIdCode

	// no validation rules for ExportCountryName

	if len(errors) > 0 {
		return ShipmentDMultiError(errors)
	}

	return nil
}

// ShipmentDMultiError is an error wrapping multiple validation errors returned
// by ShipmentD.ValidateAll() if the designated constraints aren't met.
type ShipmentDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShipmentDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShipmentDMultiError) AllErrors() []error { return m }

// ShipmentDValidationError is the validation error returned by
// ShipmentD.Validate if the designated constraints aren't met.
type ShipmentDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShipmentDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShipmentDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShipmentDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShipmentDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShipmentDValidationError) ErrorName() string { return "ShipmentDValidationError" }

// Error satisfies the builtin error interface
func (e ShipmentDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShipmentD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShipmentDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShipmentDValidationError{}

// Validate checks the field values on CreateShipmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateShipmentRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateShipmentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateShipmentRequestMultiError, or nil if none found.
func (m *CreateShipmentRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateShipmentRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ShId

	// no validation rules for ShippingPriorityLevelCode

	// no validation rules for HandlingCode

	// no validation rules for HandlingInstructions

	// no validation rules for Information

	// no validation rules for GrossWeightMeasure

	// no validation rules for NetWeightMeasure

	// no validation rules for NetNetWeightMeasure

	// no validation rules for GrossVolumeMeasure

	// no validation rules for NetVolumeMeasure

	// no validation rules for TotalGoodsItemQuantity

	// no validation rules for TotalTransportHandlingUnitQuantity

	// no validation rules for InsuranceValueAmount

	// no validation rules for DeclaredCustomsValueAmount

	// no validation rules for DeclaredForCarriageValueAmount

	// no validation rules for DeclaredStatisticsValueAmount

	// no validation rules for FreeOnBoardValueAmount

	// no validation rules for SpecialInstructions

	// no validation rules for DeliveryInstructions

	// no validation rules for SplitConsignmentIndicator

	// no validation rules for ConsignmentQuantity

	// no validation rules for ReturnAddressId

	// no validation rules for OriginAddressId

	// no validation rules for FirstArrivalPortLocationId

	// no validation rules for LastExitPortLocationId

	// no validation rules for ExportCountryIdCode

	// no validation rules for ExportCountryName

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if all {
		switch v := interface{}(m.GetReturnAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateShipmentRequestValidationError{
					field:  "ReturnAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateShipmentRequestValidationError{
					field:  "ReturnAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReturnAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateShipmentRequestValidationError{
				field:  "ReturnAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOriginalAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateShipmentRequestValidationError{
					field:  "OriginalAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateShipmentRequestValidationError{
					field:  "OriginalAddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOriginalAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateShipmentRequestValidationError{
				field:  "OriginalAddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFirstArrivalPortLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateShipmentRequestValidationError{
					field:  "FirstArrivalPortLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateShipmentRequestValidationError{
					field:  "FirstArrivalPortLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFirstArrivalPortLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateShipmentRequestValidationError{
				field:  "FirstArrivalPortLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLastExitPortLocation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateShipmentRequestValidationError{
					field:  "LastExitPortLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateShipmentRequestValidationError{
					field:  "LastExitPortLocation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLastExitPortLocation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateShipmentRequestValidationError{
				field:  "LastExitPortLocation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateShipmentRequestMultiError(errors)
	}

	return nil
}

// CreateShipmentRequestMultiError is an error wrapping multiple validation
// errors returned by CreateShipmentRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateShipmentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateShipmentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateShipmentRequestMultiError) AllErrors() []error { return m }

// CreateShipmentRequestValidationError is the validation error returned by
// CreateShipmentRequest.Validate if the designated constraints aren't met.
type CreateShipmentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateShipmentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateShipmentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateShipmentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateShipmentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateShipmentRequestValidationError) ErrorName() string {
	return "CreateShipmentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateShipmentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateShipmentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateShipmentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateShipmentRequestValidationError{}

// Validate checks the field values on CreateShipmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateShipmentResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateShipmentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateShipmentResponseMultiError, or nil if none found.
func (m *CreateShipmentResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateShipmentResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetShipment()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateShipmentResponseValidationError{
					field:  "Shipment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateShipmentResponseValidationError{
					field:  "Shipment",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetShipment()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateShipmentResponseValidationError{
				field:  "Shipment",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateShipmentResponseMultiError(errors)
	}

	return nil
}

// CreateShipmentResponseMultiError is an error wrapping multiple validation
// errors returned by CreateShipmentResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateShipmentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateShipmentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateShipmentResponseMultiError) AllErrors() []error { return m }

// CreateShipmentResponseValidationError is the validation error returned by
// CreateShipmentResponse.Validate if the designated constraints aren't met.
type CreateShipmentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateShipmentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateShipmentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateShipmentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateShipmentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateShipmentResponseValidationError) ErrorName() string {
	return "CreateShipmentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateShipmentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateShipmentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateShipmentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateShipmentResponseValidationError{}

// Validate checks the field values on AllowanceCharge with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AllowanceCharge) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AllowanceCharge with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AllowanceChargeMultiError, or nil if none found.
func (m *AllowanceCharge) ValidateAll() error {
	return m.validate(true)
}

func (m *AllowanceCharge) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for AcId

	// no validation rules for ChargeIndicator

	// no validation rules for AllowanceChargeReasonCode

	// no validation rules for AllowanceChargeReason

	// no validation rules for MultiplierFactorNumeric

	// no validation rules for PrepaidIndicator

	// no validation rules for SequenceNumeric

	// no validation rules for Amount

	// no validation rules for BaseAmount

	// no validation rules for PerUnitAmount

	// no validation rules for TaxCategoryId

	// no validation rules for TaxTotalId

	if len(errors) > 0 {
		return AllowanceChargeMultiError(errors)
	}

	return nil
}

// AllowanceChargeMultiError is an error wrapping multiple validation errors
// returned by AllowanceCharge.ValidateAll() if the designated constraints
// aren't met.
type AllowanceChargeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AllowanceChargeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AllowanceChargeMultiError) AllErrors() []error { return m }

// AllowanceChargeValidationError is the validation error returned by
// AllowanceCharge.Validate if the designated constraints aren't met.
type AllowanceChargeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AllowanceChargeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AllowanceChargeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AllowanceChargeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AllowanceChargeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AllowanceChargeValidationError) ErrorName() string { return "AllowanceChargeValidationError" }

// Error satisfies the builtin error interface
func (e AllowanceChargeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAllowanceCharge.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AllowanceChargeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AllowanceChargeValidationError{}

// Validate checks the field values on CreateAllowanceChargeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAllowanceChargeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAllowanceChargeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateAllowanceChargeRequestMultiError, or nil if none found.
func (m *CreateAllowanceChargeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAllowanceChargeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AcId

	// no validation rules for ChargeIndicator

	// no validation rules for AllowanceChargeReasonCode

	// no validation rules for AllowanceChargeReason

	// no validation rules for MultiplierFactorNumeric

	// no validation rules for PrepaidIndicator

	// no validation rules for SequenceNumeric

	// no validation rules for Amount

	// no validation rules for BaseAmount

	// no validation rules for PerUnitAmount

	// no validation rules for TaxCategoryId

	// no validation rules for TaxTotalId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateAllowanceChargeRequestMultiError(errors)
	}

	return nil
}

// CreateAllowanceChargeRequestMultiError is an error wrapping multiple
// validation errors returned by CreateAllowanceChargeRequest.ValidateAll() if
// the designated constraints aren't met.
type CreateAllowanceChargeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAllowanceChargeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAllowanceChargeRequestMultiError) AllErrors() []error { return m }

// CreateAllowanceChargeRequestValidationError is the validation error returned
// by CreateAllowanceChargeRequest.Validate if the designated constraints
// aren't met.
type CreateAllowanceChargeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAllowanceChargeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAllowanceChargeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAllowanceChargeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAllowanceChargeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAllowanceChargeRequestValidationError) ErrorName() string {
	return "CreateAllowanceChargeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAllowanceChargeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAllowanceChargeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAllowanceChargeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAllowanceChargeRequestValidationError{}

// Validate checks the field values on CreateAllowanceChargeResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateAllowanceChargeResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateAllowanceChargeResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateAllowanceChargeResponseMultiError, or nil if none found.
func (m *CreateAllowanceChargeResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateAllowanceChargeResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAllowanceCharge()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateAllowanceChargeResponseValidationError{
					field:  "AllowanceCharge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateAllowanceChargeResponseValidationError{
					field:  "AllowanceCharge",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAllowanceCharge()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateAllowanceChargeResponseValidationError{
				field:  "AllowanceCharge",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateAllowanceChargeResponseMultiError(errors)
	}

	return nil
}

// CreateAllowanceChargeResponseMultiError is an error wrapping multiple
// validation errors returned by CreateAllowanceChargeResponse.ValidateAll()
// if the designated constraints aren't met.
type CreateAllowanceChargeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAllowanceChargeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAllowanceChargeResponseMultiError) AllErrors() []error { return m }

// CreateAllowanceChargeResponseValidationError is the validation error
// returned by CreateAllowanceChargeResponse.Validate if the designated
// constraints aren't met.
type CreateAllowanceChargeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAllowanceChargeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAllowanceChargeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAllowanceChargeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAllowanceChargeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAllowanceChargeResponseValidationError) ErrorName() string {
	return "CreateAllowanceChargeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAllowanceChargeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAllowanceChargeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAllowanceChargeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAllowanceChargeResponseValidationError{}

// Validate checks the field values on BillOfLading with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BillOfLading) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillOfLading with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BillOfLadingMultiError, or
// nil if none found.
func (m *BillOfLading) ValidateAll() error {
	return m.validate(true)
}

func (m *BillOfLading) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBillOfLadingD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillOfLadingValidationError{
					field:  "BillOfLadingD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillOfLadingValidationError{
					field:  "BillOfLadingD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBillOfLadingD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillOfLadingValidationError{
				field:  "BillOfLadingD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBillOfLadingT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillOfLadingValidationError{
					field:  "BillOfLadingT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillOfLadingValidationError{
					field:  "BillOfLadingT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBillOfLadingT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillOfLadingValidationError{
				field:  "BillOfLadingT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillOfLadingValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillOfLadingValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillOfLadingValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillOfLadingValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillOfLadingValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillOfLadingValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BillOfLadingMultiError(errors)
	}

	return nil
}

// BillOfLadingMultiError is an error wrapping multiple validation errors
// returned by BillOfLading.ValidateAll() if the designated constraints aren't met.
type BillOfLadingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillOfLadingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillOfLadingMultiError) AllErrors() []error { return m }

// BillOfLadingValidationError is the validation error returned by
// BillOfLading.Validate if the designated constraints aren't met.
type BillOfLadingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillOfLadingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillOfLadingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillOfLadingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillOfLadingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillOfLadingValidationError) ErrorName() string { return "BillOfLadingValidationError" }

// Error satisfies the builtin error interface
func (e BillOfLadingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillOfLading.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillOfLadingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillOfLadingValidationError{}

// Validate checks the field values on BillOfLadingD with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BillOfLadingD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillOfLadingD with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BillOfLadingDMultiError, or
// nil if none found.
func (m *BillOfLadingD) ValidateAll() error {
	return m.validate(true)
}

func (m *BillOfLadingD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for BillOfLadingId

	// no validation rules for CarrierAssignedId

	// no validation rules for Name1

	// no validation rules for Description

	// no validation rules for Note

	// no validation rules for DocumentStatusCode

	// no validation rules for ShippingOrderId

	// no validation rules for ToOrderIndicator

	// no validation rules for AdValoremIndicator

	// no validation rules for DeclaredCarriageValueAmount

	// no validation rules for DeclaredCarriageValueAmountCurrencyCode

	// no validation rules for OtherInstruction

	// no validation rules for ConsignorPartyId

	// no validation rules for CarrierPartyId

	// no validation rules for FreightForwarderPartyId

	// no validation rules for ShipmentId

	if len(errors) > 0 {
		return BillOfLadingDMultiError(errors)
	}

	return nil
}

// BillOfLadingDMultiError is an error wrapping multiple validation errors
// returned by BillOfLadingD.ValidateAll() if the designated constraints
// aren't met.
type BillOfLadingDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillOfLadingDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillOfLadingDMultiError) AllErrors() []error { return m }

// BillOfLadingDValidationError is the validation error returned by
// BillOfLadingD.Validate if the designated constraints aren't met.
type BillOfLadingDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillOfLadingDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillOfLadingDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillOfLadingDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillOfLadingDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillOfLadingDValidationError) ErrorName() string { return "BillOfLadingDValidationError" }

// Error satisfies the builtin error interface
func (e BillOfLadingDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillOfLadingD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillOfLadingDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillOfLadingDValidationError{}

// Validate checks the field values on BillOfLadingT with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BillOfLadingT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BillOfLadingT with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BillOfLadingTMultiError, or
// nil if none found.
func (m *BillOfLadingT) ValidateAll() error {
	return m.validate(true)
}

func (m *BillOfLadingT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIssueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BillOfLadingTValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BillOfLadingTValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BillOfLadingTValidationError{
				field:  "IssueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BillOfLadingTMultiError(errors)
	}

	return nil
}

// BillOfLadingTMultiError is an error wrapping multiple validation errors
// returned by BillOfLadingT.ValidateAll() if the designated constraints
// aren't met.
type BillOfLadingTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BillOfLadingTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BillOfLadingTMultiError) AllErrors() []error { return m }

// BillOfLadingTValidationError is the validation error returned by
// BillOfLadingT.Validate if the designated constraints aren't met.
type BillOfLadingTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BillOfLadingTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BillOfLadingTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BillOfLadingTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BillOfLadingTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BillOfLadingTValidationError) ErrorName() string { return "BillOfLadingTValidationError" }

// Error satisfies the builtin error interface
func (e BillOfLadingTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBillOfLadingT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BillOfLadingTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BillOfLadingTValidationError{}

// Validate checks the field values on CreateBillOfLadingRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateBillOfLadingRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateBillOfLadingRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateBillOfLadingRequestMultiError, or nil if none found.
func (m *CreateBillOfLadingRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateBillOfLadingRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BillOfLadingId

	// no validation rules for CarrierAssignedId

	// no validation rules for IssueDate

	// no validation rules for Name1

	// no validation rules for Description

	// no validation rules for Note

	// no validation rules for DocumentStatusCode

	// no validation rules for ShippingOrderId

	// no validation rules for ToOrderIndicator

	// no validation rules for AdValoremIndicator

	// no validation rules for DeclaredCarriageValueAmount

	// no validation rules for DeclaredCarriageValueAmountCurrencyCode

	// no validation rules for OtherInstruction

	// no validation rules for ConsignorPartyId

	// no validation rules for CarrierPartyId

	// no validation rules for FreightForwarderPartyId

	// no validation rules for ShipmentId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateBillOfLadingRequestMultiError(errors)
	}

	return nil
}

// CreateBillOfLadingRequestMultiError is an error wrapping multiple validation
// errors returned by CreateBillOfLadingRequest.ValidateAll() if the
// designated constraints aren't met.
type CreateBillOfLadingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateBillOfLadingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateBillOfLadingRequestMultiError) AllErrors() []error { return m }

// CreateBillOfLadingRequestValidationError is the validation error returned by
// CreateBillOfLadingRequest.Validate if the designated constraints aren't met.
type CreateBillOfLadingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateBillOfLadingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateBillOfLadingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateBillOfLadingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateBillOfLadingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateBillOfLadingRequestValidationError) ErrorName() string {
	return "CreateBillOfLadingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateBillOfLadingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateBillOfLadingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateBillOfLadingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateBillOfLadingRequestValidationError{}

// Validate checks the field values on CreateBillOfLadingResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateBillOfLadingResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateBillOfLadingResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateBillOfLadingResponseMultiError, or nil if none found.
func (m *CreateBillOfLadingResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateBillOfLadingResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBillOfLading()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateBillOfLadingResponseValidationError{
					field:  "BillOfLading",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateBillOfLadingResponseValidationError{
					field:  "BillOfLading",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBillOfLading()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateBillOfLadingResponseValidationError{
				field:  "BillOfLading",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateBillOfLadingResponseMultiError(errors)
	}

	return nil
}

// CreateBillOfLadingResponseMultiError is an error wrapping multiple
// validation errors returned by CreateBillOfLadingResponse.ValidateAll() if
// the designated constraints aren't met.
type CreateBillOfLadingResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateBillOfLadingResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateBillOfLadingResponseMultiError) AllErrors() []error { return m }

// CreateBillOfLadingResponseValidationError is the validation error returned
// by CreateBillOfLadingResponse.Validate if the designated constraints aren't met.
type CreateBillOfLadingResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateBillOfLadingResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateBillOfLadingResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateBillOfLadingResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateBillOfLadingResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateBillOfLadingResponseValidationError) ErrorName() string {
	return "CreateBillOfLadingResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateBillOfLadingResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateBillOfLadingResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateBillOfLadingResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateBillOfLadingResponseValidationError{}

// Validate checks the field values on Waybill with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Waybill) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Waybill with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in WaybillMultiError, or nil if none found.
func (m *Waybill) ValidateAll() error {
	return m.validate(true)
}

func (m *Waybill) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetWaybillD()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WaybillValidationError{
					field:  "WaybillD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WaybillValidationError{
					field:  "WaybillD",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWaybillD()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WaybillValidationError{
				field:  "WaybillD",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetWaybillT()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WaybillValidationError{
					field:  "WaybillT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WaybillValidationError{
					field:  "WaybillT",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWaybillT()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WaybillValidationError{
				field:  "WaybillT",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdUser()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WaybillValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WaybillValidationError{
					field:  "CrUpdUser",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdUser()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WaybillValidationError{
				field:  "CrUpdUser",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCrUpdTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WaybillValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WaybillValidationError{
					field:  "CrUpdTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCrUpdTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WaybillValidationError{
				field:  "CrUpdTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WaybillMultiError(errors)
	}

	return nil
}

// WaybillMultiError is an error wrapping multiple validation errors returned
// by Waybill.ValidateAll() if the designated constraints aren't met.
type WaybillMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WaybillMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WaybillMultiError) AllErrors() []error { return m }

// WaybillValidationError is the validation error returned by Waybill.Validate
// if the designated constraints aren't met.
type WaybillValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WaybillValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WaybillValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WaybillValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WaybillValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WaybillValidationError) ErrorName() string { return "WaybillValidationError" }

// Error satisfies the builtin error interface
func (e WaybillValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWaybill.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WaybillValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WaybillValidationError{}

// Validate checks the field values on WaybillD with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WaybillD) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WaybillD with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WaybillDMultiError, or nil
// if none found.
func (m *WaybillD) ValidateAll() error {
	return m.validate(true)
}

func (m *WaybillD) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	// no validation rules for Uuid4

	// no validation rules for IdS

	// no validation rules for WaybillId

	// no validation rules for CarrierAssignedId

	// no validation rules for Name1

	// no validation rules for Description

	// no validation rules for Note

	// no validation rules for ShippingOrderId

	// no validation rules for AdValoremIndicator

	// no validation rules for DeclaredCarriageValueAmount

	// no validation rules for DeclaredCarriageValueAmountCurrencyCode

	// no validation rules for OtherInstruction

	// no validation rules for ConsignorPartyId

	// no validation rules for CarrierPartyId

	// no validation rules for FreightForwarderPartyId

	// no validation rules for ShipmentId

	if len(errors) > 0 {
		return WaybillDMultiError(errors)
	}

	return nil
}

// WaybillDMultiError is an error wrapping multiple validation errors returned
// by WaybillD.ValidateAll() if the designated constraints aren't met.
type WaybillDMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WaybillDMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WaybillDMultiError) AllErrors() []error { return m }

// WaybillDValidationError is the validation error returned by
// WaybillD.Validate if the designated constraints aren't met.
type WaybillDValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WaybillDValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WaybillDValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WaybillDValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WaybillDValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WaybillDValidationError) ErrorName() string { return "WaybillDValidationError" }

// Error satisfies the builtin error interface
func (e WaybillDValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWaybillD.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WaybillDValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WaybillDValidationError{}

// Validate checks the field values on WaybillT with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WaybillT) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WaybillT with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WaybillTMultiError, or nil
// if none found.
func (m *WaybillT) ValidateAll() error {
	return m.validate(true)
}

func (m *WaybillT) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIssueDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WaybillTValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WaybillTValidationError{
					field:  "IssueDate",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIssueDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WaybillTValidationError{
				field:  "IssueDate",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WaybillTMultiError(errors)
	}

	return nil
}

// WaybillTMultiError is an error wrapping multiple validation errors returned
// by WaybillT.ValidateAll() if the designated constraints aren't met.
type WaybillTMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WaybillTMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WaybillTMultiError) AllErrors() []error { return m }

// WaybillTValidationError is the validation error returned by
// WaybillT.Validate if the designated constraints aren't met.
type WaybillTValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WaybillTValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WaybillTValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WaybillTValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WaybillTValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WaybillTValidationError) ErrorName() string { return "WaybillTValidationError" }

// Error satisfies the builtin error interface
func (e WaybillTValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWaybillT.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WaybillTValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WaybillTValidationError{}

// Validate checks the field values on CreateWaybillRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateWaybillRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateWaybillRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateWaybillRequestMultiError, or nil if none found.
func (m *CreateWaybillRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateWaybillRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WaybillId

	// no validation rules for CarrierAssignedId

	// no validation rules for IssueDate

	// no validation rules for Name1

	// no validation rules for Description

	// no validation rules for Note

	// no validation rules for ShippingOrderId

	// no validation rules for AdValoremIndicator

	// no validation rules for DeclaredCarriageValueAmount

	// no validation rules for DeclaredCarriageValueAmountCurrencyCode

	// no validation rules for OtherInstruction

	// no validation rules for ConsignorPartyId

	// no validation rules for CarrierPartyId

	// no validation rules for FreightForwarderPartyId

	// no validation rules for ShipmentId

	// no validation rules for UserId

	// no validation rules for UserEmail

	// no validation rules for RequestId

	if len(errors) > 0 {
		return CreateWaybillRequestMultiError(errors)
	}

	return nil
}

// CreateWaybillRequestMultiError is an error wrapping multiple validation
// errors returned by CreateWaybillRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateWaybillRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWaybillRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWaybillRequestMultiError) AllErrors() []error { return m }

// CreateWaybillRequestValidationError is the validation error returned by
// CreateWaybillRequest.Validate if the designated constraints aren't met.
type CreateWaybillRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWaybillRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWaybillRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWaybillRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWaybillRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWaybillRequestValidationError) ErrorName() string {
	return "CreateWaybillRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWaybillRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWaybillRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWaybillRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWaybillRequestValidationError{}

// Validate checks the field values on CreateWaybillResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateWaybillResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateWaybillResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateWaybillResponseMultiError, or nil if none found.
func (m *CreateWaybillResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateWaybillResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetWaybill()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateWaybillResponseValidationError{
					field:  "Waybill",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateWaybillResponseValidationError{
					field:  "Waybill",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWaybill()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateWaybillResponseValidationError{
				field:  "Waybill",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateWaybillResponseMultiError(errors)
	}

	return nil
}

// CreateWaybillResponseMultiError is an error wrapping multiple validation
// errors returned by CreateWaybillResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateWaybillResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWaybillResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWaybillResponseMultiError) AllErrors() []error { return m }

// CreateWaybillResponseValidationError is the validation error returned by
// CreateWaybillResponse.Validate if the designated constraints aren't met.
type CreateWaybillResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWaybillResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWaybillResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWaybillResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWaybillResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWaybillResponseValidationError) ErrorName() string {
	return "CreateWaybillResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWaybillResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWaybillResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWaybillResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWaybillResponseValidationError{}
